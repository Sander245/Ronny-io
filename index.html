<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RONNY IO - Multiplayer Tank Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #e0e0e0;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            background: #d8d8d8;
            image-rendering: crisp-edges;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
        }

        #startMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #startMenu.hidden {
            display: none;
        }

        .menu-content {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        .menu-title {
            font-size: 72px;
            font-weight: bold;
            color: white;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            margin-bottom: 30px;
        }

        #nameInput {
            font-size: 24px;
            padding: 15px 30px;
            border: none;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            border-radius: 10px;
            margin-bottom: 20px;
            width: 300px;
            text-align: center;
            outline: none;
        }

        #playButton {
            font-size: 28px;
            padding: 15px 60px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        #playButton:hover {
            background: #45a049;
            transform: scale(1.05);
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            display: none; /* Hidden by default */
        }

        #hud.visible {
            display: block;
        }

        .hud-item {
            margin-bottom: 5px;
        }

        .health-bar {
            width: 200px;
            height: 25px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50px;
            overflow: hidden;
            margin-top: 5px;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF4444, #FF8888);
            transition: width 0.3s;
            border-radius: 50px;
        }

        .xp-bar {
            width: 300px;
            height: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50px;
            overflow: hidden;
            margin-top: 5px;
        }

        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            transition: width 0.3s;
            border-radius: 50px;
        }

        #upgradeMenu {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            color: white;
            max-width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            z-index: 200;
        }

        #upgradeMenu::-webkit-scrollbar {
            width: 8px;
        }

        #upgradeMenu::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        #upgradeMenu::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 4px;
        }

        #upgradeMenu::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.7);
        }

        #upgradeMenu.visible {
            display: block;
        }

        .upgrade-section {
            margin-bottom: 20px;
        }

        .upgrade-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
            border-bottom: 2px solid white;
            padding-bottom: 5px;
        }

        .stat-upgrade {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .stat-upgrade:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .stat-upgrade.maxed {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .stat-bars {
            display: flex;
            gap: 2px;
        }

        .stat-bar {
            width: 15px;
            height: 15px;
            background: rgba(255, 255, 255, 0.3);
            border: 1px solid white;
        }

        .stat-bar.filled {
            background: #FFD700;
        }

        .tank-upgrade {
            background: rgba(100, 150, 255, 0.3);
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .tank-upgrade:hover:not(.locked) {
            background: rgba(100, 150, 255, 0.5);
            border-color: white;
            transform: scale(1.02);
        }

        .tank-upgrade.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #tankUpgrades {
            max-height: 200px;
            overflow-y: auto;
        }

        #tankUpgrades::-webkit-scrollbar {
            width: 6px;
        }

        #tankUpgrades::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        #tankUpgrades::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 3px;
        }

        .tank-name {
            font-weight: bold;
            font-size: 16px;
        }

        .tank-level {
            font-size: 12px;
            color: #FFD700;
        }

        #leaderboard {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            min-width: 200px;
            margin-bottom: 10px;
        }

        #leaderboard.hidden {
            display: none;
        }

        .leaderboard-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 2px solid white;
            padding-bottom: 5px;
        }

        .leaderboard-entry {
            padding: 5px;
            margin: 3px 0;
            font-size: 14px;
        }

        .leaderboard-entry:nth-child(2) {
            color: #FFD700;
        }

        .leaderboard-entry:nth-child(3) {
            color: #C0C0C0;
        }

        .leaderboard-entry:nth-child(4) {
            color: #CD7F32;
        }

        #chatContainer {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 230px;
            z-index: 100;
        }

        #chatMessages {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 10px;
            color: white;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .chat-message {
            margin: 3px 0;
            word-wrap: break-word;
        }

        #chatInputBox {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #555;
            border-radius: 5px;
            color: white;
            font-size: 14px;
            box-sizing: border-box;
        }

        #chatInputBox:focus {
            outline: none;
            border-color: #00B2E1;
        }

        #minimap {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid white;
            border-radius: 50%;
            overflow: hidden;
        }

        .controls-help {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 14px;
            z-index: 100;
        }

        .controls-help.hidden {
            display: none;
        }

        .control-item {
            margin: 5px 0;
        }

        .control-item.active {
            color: #4CAF50;
            font-weight: bold;
        }

        #deathScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 500;
        }

        #deathScreen.visible {
            display: flex;
        }

        .death-content {
            text-align: center;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 40px;
            border-radius: 20px;
        }

        .death-title {
            font-size: 48px;
            font-weight: bold;
            color: #FF4444;
            margin-bottom: 20px;
        }

        .killed-by {
            font-size: 24px;
            margin: 10px 0;
        }

        .killer-name {
            color: #FFD700;
            font-weight: bold;
        }

        .respawn-timer {
            font-size: 18px;
            margin-top: 20px;
            color: #888;
        }

        .upgrade-points {
            font-size: 14px;
            color: #FFD700;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="startMenu">
        <div class="menu-content">
            <div class="menu-title">RONNY IO</div>
            <input type="text" id="nameInput" placeholder="Enter your name" maxlength="20">
            <br>
            <button id="playButton">PLAY</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="hud">
        <div class="hud-item">Score: <span id="score">0</span></div>
        <div class="hud-item">Level: <span id="level">1</span></div>
        <div class="health-bar">
            <div class="health-fill" id="healthFill"></div>
        </div>
        <div class="xp-bar">
            <div class="xp-fill" id="xpFill"></div>
        </div>
        
        <!-- Minimap -->
        <canvas id="minimap" width="150" height="150" style="position: absolute; left: 10px; top: 120px; border: 3px solid #404040; border-radius: 5px; background: rgba(0, 0, 0, 0.5);"></canvas>
    </div>

    <div id="upgradeMenu">
        <div class="upgrade-section">
            <div class="upgrade-title">Stats</div>
            <div id="upgradePointsDisplay" style="color: #ffd700; font-size: 16px; font-weight: bold; margin-bottom: 10px; text-align: center;">Upgrade Points: 0</div>
            <div id="statUpgrades"></div>
            <button id="viewUpgradeTreeBtn" style="display: none; margin-top: 10px; padding: 8px 16px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">View Full Upgrade Tree</button>
        </div>
        <div class="upgrade-section" id="tankUpgradeSection" style="display: none;">
            <div class="upgrade-title">Tank Upgrades</div>
            <div id="tankUpgrades"></div>
        </div>
    </div>

    <div id="upgradeTreeModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; overflow: auto;">
        <div style="position: relative; width: 100%; min-height: 100%; padding: 40px;">
            <button id="closeUpgradeTreeBtn" style="position: fixed; top: 20px; right: 20px; padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; z-index: 10001;">Close</button>
            <div style="position: fixed; top: 20px; left: 20px; z-index: 10001; display: flex; gap: 10px;">
                <button id="zoomInTreeBtn" style="padding: 10px 15px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">+</button>
                <button id="zoomOutTreeBtn" style="padding: 10px 15px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">-</button>
                <button id="resetTreeBtn" style="padding: 10px 15px; background: #44ff44; color: black; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Reset</button>
            </div>
            <canvas id="upgradeTreeCanvas" style="background: #2a2a2a; border-radius: 8px; display: block; margin: 0 auto;"></canvas>
        </div>
    </div>

    <div id="chatContainer">
        <div id="leaderboard">
            <div class="leaderboard-title">Leaderboard</div>
            <div id="leaderboardList"></div>
        </div>
        <div id="chatMessages"></div>
        <input type="text" id="chatInputBox" placeholder="Press Enter to chat..." maxlength="100">
    </div>

    <div class="controls-help hidden" id="controlsHelp">
        <div class="control-item" id="controlWASD"><strong>WASD</strong> - Move</div>
        <div class="control-item" id="controlMouse"><strong>Mouse</strong> - Aim</div>
        <div class="control-item" id="controlClick"><strong>Click</strong> - Shoot</div>
        <div class="control-item" id="controlE"><strong>E</strong> - Auto Fire</div>
        <div class="control-item" id="controlI"><strong>I</strong> - Toggle Upgrades</div>
        <div class="control-item" id="controlH"><strong>H</strong> - Hold for Help</div>
    </div>

    <div id="cheatPanel" style="display: none; position: absolute; bottom: 10px; left: 10px; background: rgba(255, 0, 0, 0.8); color: white; padding: 15px; border-radius: 10px; font-size: 14px; z-index: 1000;">
        <div style="font-weight: bold; margin-bottom: 10px;">ðŸ”§ ADMIN PANEL ACTIVE</div>
        <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px;">
            <strong>Shift+G</strong> - Give XP: 
            <button id="decreaseXP" style="padding: 2px 8px; background: #ff4444; color: white; border: none; border-radius: 3px; cursor: pointer; font-weight: bold;">-</button>
            <span id="xpAmount" style="min-width: 60px; text-align: center; font-weight: bold;">100</span>
            <button id="increaseXP" style="padding: 2px 8px; background: #44ff44; color: white; border: none; border-radius: 3px; cursor: pointer; font-weight: bold;">+</button>
        </div>
        <div><strong>Shift+B</strong> - Max Stats (Level 1000)</div>
        <div><strong>Shift+I</strong> - Toggle Invincibility</div>
        <div style="display: flex; align-items: center; gap: 5px;">
            <div><strong>Shift+T</strong> - Teleport</div>
            <button id="tpModeAll" style="padding: 2px 8px; background: #44ff44; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">All</button>
            <button id="tpModeOthers" style="padding: 2px 8px; background: #666; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Others</button>
            <button id="tpModeYou" style="padding: 2px 8px; background: #666; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">You</button>
        </div>
        <div><strong>Shift+C</strong> - Clear All Polygons</div>
        <div><strong>Shift+A</strong> - Morph to ADMIN Tank</div>
        <div style="display: flex; align-items: center; gap: 5px; margin-top: 5px;">
            <strong>Shift+1</strong> - Spawn: 
            <button id="prevPolygon" style="padding: 2px 8px; background: #ff4444; color: white; border: none; border-radius: 3px; cursor: pointer; font-weight: bold;">â—€</button>
            <span id="polygonDisplay" style="min-width: 150px; text-align: center; font-weight: bold;">Triangle (Tier 1)</span>
            <button id="nextPolygon" style="padding: 2px 8px; background: #44ff44; color: white; border: none; border-radius: 3px; cursor: pointer; font-weight: bold;">â–¶</button>
        </div>
        <div><strong>9</strong> - Spawn All Polygon Types at Cursor</div>
        <div><strong>Shift+R</strong> - Reset Tank & Upgrades</div>
        <div><strong>ESC</strong> - Close Panel</div>
        <button id="openTankEditorBtn" style="margin-top: 10px; padding: 5px 10px; background: #ff9500; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%; font-weight: bold;">ðŸŽ¨ Tank Editor</button>
        <button id="viewUpgradeTreeCheat" style="margin-top: 10px; padding: 5px 10px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%;">View Upgrade Tree (Click to Morph)</button>
    </div>


    <div id="deathScreen">
        <div class="death-content">
            <div class="death-title">YOU DIED</div>
            <div id="killedByList"></div>
            <div class="respawn-timer">Respawning...</div>
        </div>
    </div>

    <!-- Tank Editor -->
    <div id="tankEditor" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a1a; z-index: 20000;">
        <!-- Left Panel - Block Menu & Settings -->
        <div id="editorLeftPanel" style="position: absolute; left: 0; top: 0; width: 250px; height: 100%; background: #2a2a2a; border-right: 2px solid #444; overflow-y: auto; padding: 15px; box-sizing: border-box; display: flex; flex-direction: column; gap: 20px;">
            <!-- Current Guns Section -->
            <div style="flex-shrink: 0;">
                <h2 style="color: #fff; margin-top: 0; margin-bottom: 15px;">Current Guns</h2>
                <div id="currentBlocksList" style="display: flex; flex-direction: column; gap: 6px; max-height: 200px; overflow-y: auto;">
                    <div style="color: #888; font-size: 12px; font-style: italic;">No guns added yet</div>
                </div>
            </div>
            
            <!-- Add Guns Section -->
            <div style="flex-shrink: 0; border-top: 2px solid #444; padding-top: 15px;">
                <h2 style="color: #fff; margin-top: 0; margin-bottom: 15px;">Add Gun</h2>
                <div id="gunBlocksList" style="display: flex; flex-direction: column; gap: 8px;"></div>
            </div>
            
            <!-- Tank Settings Section -->
            <div style="flex-shrink: 0; border-top: 2px solid #444; padding-top: 15px;">
                <h2 style="color: #fff; margin-top: 0; margin-bottom: 15px;">Tank Settings</h2>
                
                <!-- Tank Level -->
                <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 13px;">Level Required:</label>
                <input type="number" id="tankLevelInput" min="1" max="45" value="1" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; margin-bottom: 10px;">
                
                <!-- FOV -->
                <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 13px;">Field of View (FOV):</label>
                <input type="number" id="tankFovInput" min="0.5" max="2" step="0.1" value="1" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; margin-bottom: 15px;">
                
                <!-- Base Shape Mode -->
                <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 13px;">Base Mode:</label>
                <select id="baseModeSelect" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; margin-bottom: 10px;">
                    <option value="none">None (Circle)</option>
                    <option value="simple">Simple (Polygon)</option>
                    <option value="advanced">Advanced (Custom)</option>
                </select>
                
                <!-- Simple Base Settings (shown only for simple mode) -->
                <div id="simpleBaseSettings" style="display: none;">
                    <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 13px;">Number of Sides:</label>
                    <input type="number" id="baseSidesInput" min="3" max="16" value="4" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; margin-bottom: 10px;">
                </div>
                
                <!-- Advanced Base Settings (shown only for advanced mode) -->
                <div id="advancedBaseSettings" style="display: none;">
                    <h3 style="color: #fff; margin: 10px 0 5px 0; font-size: 14px;">Base Blocks:</h3>
                    <div id="baseBlocksList" style="display: flex; flex-direction: column; gap: 6px; max-height: 150px; overflow-y: auto; margin-bottom: 10px;">
                        <div style="color: #888; font-size: 12px; font-style: italic;">No base blocks added</div>
                    </div>
                    <button id="addBaseBlockBtn" style="width: 100%; padding: 8px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">+ Add Base Block</button>
                </div>
                
                <!-- Blade Settings -->
                <div style="border-top: 2px solid #444; margin-top: 15px; padding-top: 15px;">
                    <h3 style="color: #fff; margin-top: 0; margin-bottom: 10px; font-size: 14px;">Blades:</h3>
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; color: #aaa; font-size: 12px; margin-bottom: 5px;">Blade Damage Multiplier:</label>
                        <input id="bladeDamageMultiplier" type="number" step="0.1" value="1" min="0" style="width: 100%; padding: 6px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; box-sizing: border-box;">
                    </div>
                    <div id="bladesList" style="display: flex; flex-direction: column; gap: 6px; max-height: 200px; overflow-y: auto; margin-bottom: 10px;">
                        <div style="color: #888; font-size: 12px; font-style: italic;">No blades added</div>
                    </div>
                    <button id="addBladeBtn" style="width: 100%; padding: 8px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">+ Add Blade</button>
                </div>
            </div>
        </div>

        <!-- Center Panel - Visual Editor -->
        <div id="editorCenterPanel" style="position: absolute; left: 250px; top: 0; right: 300px; height: 100%; background: #1a1a1a; display: flex; flex-direction: column;">
            <div style="background: #2a2a2a; padding: 15px; border-bottom: 2px solid #444; display: flex; justify-content: space-between; align-items: center;">
                <h1 style="color: #fff; margin: 0;">Tank Editor</h1>
                <div style="display: flex; gap: 10px;">
                    <button id="editorExportJSONBtn" style="padding: 10px 20px; background: #ff9500; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">ðŸ“‹ Export JSON</button>
                    <button id="editorTestBtn" style="padding: 10px 20px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Test</button>
                    <button id="editorCancelBtn" style="padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Cancel</button>
                    <button id="editorSaveBtn" style="padding: 10px 20px; background: #44ff44; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Save</button>
                </div>
            </div>
            <div style="flex: 1; position: relative; overflow: hidden;">
                <canvas id="editorCanvas" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #0f0f0f; cursor: grab;"></canvas>
            </div>
        </div>

        <!-- Right Panel - Properties -->
        <div id="editorRightPanel" style="position: absolute; right: 0; top: 0; width: 300px; height: 100%; background: #2a2a2a; border-left: 2px solid #444; overflow-y: auto; padding: 15px; box-sizing: border-box;">
            <h2 style="color: #fff; margin-top: 0; margin-bottom: 15px;">Properties</h2>
            <div id="editorPropertiesContent" style="color: #aaa; font-size: 14px;">
                Select a block to edit its properties
            </div>
        </div>
    </div>

    <!-- Save Tank Modal -->
    <div id="saveTankModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 30000; justify-content: center; align-items: center;">
        <div style="background: #2a2a2a; padding: 30px; border-radius: 10px; max-width: 700px; width: 90%; max-height: 90vh; overflow-y: auto; color: white;">
            <h2 style="margin-top: 0;">Save Tank</h2>
            
            <label style="display: block; margin-bottom: 5px; color: #aaa;">Tank Name:</label>
            <input id="saveTankName" type="text" placeholder="Enter tank name" style="width: 100%; padding: 10px; margin-bottom: 15px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; box-sizing: border-box;">
            
            <label style="display: block; margin-bottom: 5px; color: #aaa;">Required Level:</label>
            <input id="saveTankLevel" type="number" value="1" min="1" style="width: 100%; padding: 10px; margin-bottom: 15px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; box-sizing: border-box;">
            
            <label style="display: block; margin-bottom: 5px; color: #aaa;">Upgrade From (click tanks to add):</label>
            <input id="saveTankUpgrades" type="text" placeholder="Selected tanks will appear here" readonly style="width: 100%; padding: 10px; margin-bottom: 10px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; box-sizing: border-box; cursor: default;">
            
            <div id="tankSelectorGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; max-height: 300px; overflow-y: auto; margin-bottom: 15px; padding: 10px; background: #1a1a1a; border-radius: 4px;">
                <!-- Tank selector buttons will be populated here -->
            </div>
            
            <label style="display: flex; align-items: center; margin-bottom: 15px; cursor: pointer;">
                <input id="saveTankHideFromTree" type="checkbox" style="margin-right: 10px;">
                <span>Hide from upgrade tree</span>
            </label>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="saveTankCancelBtn" style="padding: 10px 20px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                <button id="saveTankConfirmBtn" style="padding: 10px 20px; background: #44ff44; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">Save</button>
            </div>
        </div>
    </div>

    <!-- Test Area (overlays the game for testing) -->
    <div id="testArea" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 25000; pointer-events: none;">
        <div style="position: absolute; top: 20px; right: 20px; z-index: 1; pointer-events: all;">
            <button id="exitTestBtn" style="padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold;">Exit Test</button>
        </div>
        <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(255, 149, 0, 0.9); color: white; padding: 10px 20px; border-radius: 4px; font-weight: bold; pointer-events: none;">
            ðŸŽ¨ TESTING TANK - Click "Exit Test" when done
        </div>
    </div>

    <!-- Load Socket.IO from CDN for GitHub Pages compatibility -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Connect to server - Auto-detect Railway deployment or local
        // Railway will automatically provide the correct URL via window.location
        const socket = io();
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Game state
        let playerId = null;
        let gameState = null;
        let tankTypes = null;
        let tankUpgrades = null;
        let camera = { x: 0, y: 0, zoom: 1 };
        let targetCamera = { x: 0, y: 0 };
        let mouseWorldX = 0;
        let mouseWorldY = 0;
        let lastMouseScreenX = 0; // Track last screen mouse position
        let lastMouseScreenY = 0;
        let autoFire = false;
        let mouseDown = false;
        let upgradeMenuVisible = false;
        let showingHelp = false;
        let helpTimeout = null;
        let hasMovedOrShot = false;
        let keysPressed = {}; // Track which keys are currently pressed
        let lastKnownLevel = 0; // Track level to detect level ups
        let showAllHealthBars = false; // Toggle for showing all health bars (N key)
        
        // Cheat code tracking
        let cheatCodeBuffer = '';
        let cheatPanelActive = false;
        let xpAmount = 100; // Variable XP amount for give XP cheat
        
        // Polygon spawn system
        let selectedPolygonIndex = 0;
        const polygonTypes = [
            { sides: 3, name: 'Triangle', tier: 1 },
            { sides: 4, name: 'Square', tier: 1 },
            { sides: 5, name: 'Pentagon', tier: 2 },
            { sides: 6, name: 'Hexagon', tier: 2 },
            { sides: 8, name: 'Octagon', tier: 3 },
            { sides: 10, name: 'Decagon', tier: 3 },
            { sides: 12, name: 'Dodecagon', tier: 4 },
            { sides: 13, name: 'Tridecagon', tier: 4 },
            { sides: 14, name: 'Tetradecagon', tier: 5 },
            { sides: 15, name: 'Pentadecagon', tier: 5 },
            { sides: 16, name: 'Hexadecagon', tier: 5 }
        ];

        // Input state
        const input = {
            moving: { up: false, down: false, left: false, right: false },
            shooting: false,
            mouseX: 0,
            mouseY: 0
        };

        // Constants
        const MAP_RADIUS = 3000;
        const GRID_SIZE = 25; // More compact grid

        // Disable right-click context menu
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Disable browser zoom with Ctrl+/- and Ctrl+scroll
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '=')) {
                e.preventDefault();
            }
        });

        document.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
            }
        }, { passive: false });

        // Camera helper
        function setCameraSize(fov) {
            camera.zoom = 1 / fov;
        }

        function screenToWorld(screenX, screenY) {
            const worldX = (screenX - canvas.width / 2) / camera.zoom + camera.x;
            const worldY = (screenY - canvas.height / 2) / camera.zoom + camera.y;
            return { x: worldX, y: worldY };
        }

        function worldToScreen(worldX, worldY) {
            const screenX = (worldX - camera.x) * camera.zoom + canvas.width / 2;
            const screenY = (worldY - camera.y) * camera.zoom + canvas.height / 2;
            return { x: screenX, y: screenY };
        }

        // Calculate distance from center to edge of base at given angle
        function getBaseRadiusAtAngle(player, angle) {
            return getBaseRadiusAndFaceAtAngle(player, angle).radius;
        }

        // Get both radius and face angle at a specific angle
        function getBaseRadiusAndFaceAtAngle(player, angle) {
            const tankConfig = tankTypes[player.tankType];
            if (!tankConfig) return { radius: player.size, faceAngle: angle };
            
            // For circle or simple polygon base
            if (typeof tankConfig.baseShape === 'number') {
                const sides = tankConfig.baseShape;
                if (sides === 0) {
                    // Circle - constant radius, face perpendicular to radius
                    return { radius: player.size, faceAngle: angle };
                } else {
                    // Regular polygon - calculate distance to edge at this angle
                    const anglePerSide = (Math.PI * 2) / sides;
                    
                    // Find which side this angle points to
                    const normalizedAngle = angle + Math.PI / 2;
                    const sideIndex = Math.floor((normalizedAngle + anglePerSide / 2) / anglePerSide);
                    const sideAngle = sideIndex * anglePerSide;
                    
                    // Distance from center to edge of regular polygon at given angle
                    const angleToEdge = angle - sideAngle + Math.PI / 2;
                    const cosAngle = Math.cos(angleToEdge);
                    
                    const radius = Math.abs(cosAngle) > 0.001 ? player.size / cosAngle : player.size;
                    
                    // Face angle is perpendicular to the side
                    const faceAngle = sideAngle - Math.PI / 2;
                    
                    return { radius, faceAngle };
                }
            }
            
            // For advanced base, use conservative estimate (circle)
            return { radius: player.size, faceAngle: angle };
        }

        // Event listeners
        document.getElementById('playButton').addEventListener('click', () => {
            const name = document.getElementById('nameInput').value || 'Tank';
            socket.emit('joinGame', name);
            document.getElementById('startMenu').classList.add('hidden');
            document.getElementById('hud').classList.add('visible');
        });

        document.getElementById('nameInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('playButton').click();
            }
        });

        window.addEventListener('keydown', (e) => {
            // Only allow cheat code detection when in game
            if (!playerId && !cheatPanelActive) return;
            
            // Cheat code detection (only when in game)
            if (playerId && e.key.length === 1 && !cheatPanelActive) {
                cheatCodeBuffer += e.key.toLowerCase();
                if (cheatCodeBuffer.length > 20) {
                    cheatCodeBuffer = cheatCodeBuffer.slice(-20);
                }
                if (cheatCodeBuffer.includes('ronnyisskibidi')) {
                    // Send verification to server
                    socket.emit('verifyAdminCode', 'ronnyisskibidi');
                    cheatCodeBuffer = '';
                }
            }
            
            // Handle cheat panel commands (require Shift key)
            if (cheatPanelActive && e.shiftKey) {
                if (e.key === 'g' || e.key === 'G') {
                    socket.emit('cheatGiveXP', xpAmount);
                    return;
                }
                if (e.key === 'b' || e.key === 'B') {
                    socket.emit('cheatMaxStats');
                    return;
                }
                if (e.key === 'i' || e.key === 'I') {
                    socket.emit('cheatToggleInvincibility');
                    return;
                }
                if (e.key === 't' || e.key === 'T') {
                    socket.emit('cheatTeleportPlayers', { x: mouseWorldX, y: mouseWorldY, mode: teleportMode });
                    return;
                }
                if (e.key === 'c' || e.key === 'C') {
                    socket.emit('cheatClearPolygons');
                    console.log('Clearing all polygons...');
                    return;
                }
                if (e.key === 'a' || e.key === 'A') {
                    socket.emit('cheatMorphAdmin');
                    console.log('Morphing to ADMIN tank...');
                    return;
                }
                if (e.key === 'r' || e.key === 'R') {
                    socket.emit('cheatResetTank');
                    return;
                }
                // Shift+1 spawns selected polygon
                if (e.key === '!') {
                    const polygon = polygonTypes[selectedPolygonIndex];
                    console.log(`[POLYGON SPAWN] Spawning ${polygon.name} (${polygon.sides}-sided, tier ${polygon.tier})`);
                    socket.emit('cheatSpawnPolygon', { type: polygon.sides, x: mouseWorldX, y: mouseWorldY });
                    return;
                }
            }
            
            // Handle polygon spawning - 9 for all types
            if (cheatPanelActive && e.key === '9') {
                const allTypes = [3, 4, 5, 6, 8, 10, 12, 13, 14, 15, 16];
                console.log('[POLYGON SPAWN] Spawning all types');
                allTypes.forEach((type, index) => {
                    const offsetX = (index % 4) * 30 - 45;
                    const offsetY = Math.floor(index / 4) * 30 - 30;
                    socket.emit('cheatSpawnPolygon', { type, x: mouseWorldX + offsetX, y: mouseWorldY + offsetY });
                });
                return;
            }
            
            // Close admin panel with Escape (no shift required)
            if (cheatPanelActive && e.key === 'Escape') {
                cheatPanelActive = false;
                document.getElementById('cheatPanel').style.display = 'none';
                console.log('Cheat panel deactivated');
                return;
            }
            
            // Toggle health bars with 'n' key (only in game)
            if (playerId && !chatFocused && (e.key === 'n' || e.key === 'N')) {
                showAllHealthBars = !showAllHealthBars;
                console.log('Health bars:', showAllHealthBars ? 'ON' : 'OFF');
            }
            
            // Movement and game controls - only work when in game
            if (!playerId) return;
            
            if (!chatFocused && (e.key === 'w' || e.key === 'W')) {
                input.moving.up = true;
                hasMovedOrShot = true;
                hideHelpIfTimeout();
            }
            if (!chatFocused && (e.key === 's' || e.key === 'S')) {
                input.moving.down = true;
                hasMovedOrShot = true;
                hideHelpIfTimeout();
            }
            if (!chatFocused && (e.key === 'a' || e.key === 'A')) {
                input.moving.left = true;
                hasMovedOrShot = true;
                hideHelpIfTimeout();
            }
            if (!chatFocused && (e.key === 'd' || e.key === 'D')) {
                input.moving.right = true;
                hasMovedOrShot = true;
                hideHelpIfTimeout();
            }
            if (!chatFocused && (e.key === 'e' || e.key === 'E')) {
                if (!keysPressed['e']) {
                    keysPressed['e'] = true;
                    autoFire = !autoFire;
                    // When turning autofire off, also stop shooting unless mouse is held
                    if (!autoFire && !mouseDown) {
                        input.shooting = false;
                    }
                    updateControlHighlights();
                }
            }
            if (!chatFocused && (e.key === 'i' || e.key === 'I')) {
                if (!keysPressed['i']) {
                    keysPressed['i'] = true;
                    upgradeMenuVisible = !upgradeMenuVisible;
                    updateUIVisibility();
                }
            }
            if (!chatFocused && (e.key === 'h' || e.key === 'H')) {
                showingHelp = true;
                document.getElementById('controlsHelp').classList.remove('hidden');
                updateControlHighlights();
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'w' || e.key === 'W') input.moving.up = false;
            if (e.key === 's' || e.key === 'S') input.moving.down = false;
            if (e.key === 'a' || e.key === 'A') input.moving.left = false;
            if (e.key === 'd' || e.key === 'D') input.moving.right = false;
            if (e.key === 'e' || e.key === 'E') keysPressed['e'] = false;
            if (e.key === 'i' || e.key === 'I') keysPressed['i'] = false;
            if (e.key === 'h' || e.key === 'H') {
                showingHelp = false;
                if (hasMovedOrShot) {
                    document.getElementById('controlsHelp').classList.add('hidden');
                }
                updateControlHighlights();
            }
        });

        // Chat system
        let chatFocused = false;
        const chatInputBox = document.getElementById('chatInputBox');
        const chatMessages = document.getElementById('chatMessages');
        const maxChatMessages = 20;

        // Focus chat on Enter or click
        chatInputBox.addEventListener('click', () => {
            chatFocused = true;
        });

        chatInputBox.addEventListener('focus', () => {
            chatFocused = true;
        });

        chatInputBox.addEventListener('blur', () => {
            chatFocused = false;
        });

        // Handle Enter key for chat
        chatInputBox.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const message = chatInputBox.value.trim();
                if (message.length > 0) {
                    // Send chat message to server
                    socket.emit('chatMessage', message);
                    chatInputBox.value = '';
                }
                chatInputBox.blur();
                chatFocused = false;
            } else if (e.key === 'Escape') {
                chatInputBox.blur();
                chatFocused = false;
            }
        });

        // Listen for Enter key to focus chat (when not already focused)
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !chatFocused && playerId) {
                e.preventDefault();
                chatInputBox.focus();
                chatFocused = true;
            }
        });

        // Receive chat messages from server
        socket.on('chatMessage', (data) => {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';
            messageDiv.textContent = `${data.name}: ${data.message}`;
            chatMessages.appendChild(messageDiv);
            
            // Remove old messages
            while (chatMessages.children.length > maxChatMessages) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
            
            // Auto-scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
        });

        let mouseDownOnCanvas = false;

        canvas.addEventListener('mousedown', () => {
            mouseDownOnCanvas = true;
            mouseDown = true;
            input.shooting = true;
            hasMovedOrShot = true;
            hideHelpIfTimeout();
            updateControlHighlights();
        });

        canvas.addEventListener('mouseup', () => {
            // Only register as a click if mousedown also happened on canvas
            if (mouseDownOnCanvas) {
                mouseDown = false;
                input.shooting = false;
            }
            mouseDownOnCanvas = false;
            updateControlHighlights();
        });

        // Handle mouseup outside canvas
        document.addEventListener('mouseup', () => {
            if (mouseDownOnCanvas) {
                mouseDown = false;
                input.shooting = false;
                mouseDownOnCanvas = false;
                updateControlHighlights();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            lastMouseScreenX = e.clientX;
            lastMouseScreenY = e.clientY;
            const world = screenToWorld(e.clientX, e.clientY);
            mouseWorldX = world.x;
            mouseWorldY = world.y;
        });

        // Helper functions for UI management
        function hideHelpIfTimeout() {
            if (helpTimeout) {
                clearTimeout(helpTimeout);
                helpTimeout = null;
            }
            if (hasMovedOrShot && !showingHelp) {
                document.getElementById('controlsHelp').classList.add('hidden');
            }
        }

        function updateUIVisibility() {
            const upgradeMenu = document.getElementById('upgradeMenu');
            const leaderboard = document.getElementById('leaderboard');
            
            if (upgradeMenuVisible) {
                upgradeMenu.classList.add('visible');
                leaderboard.classList.add('hidden');
            } else {
                upgradeMenu.classList.remove('visible');
                leaderboard.classList.remove('hidden');
            }
        }

        function updateControlHighlights() {
            // WASD highlighting
            const wasdControl = document.getElementById('controlWASD');
            if (input.moving.up || input.moving.down || input.moving.left || input.moving.right) {
                wasdControl.classList.add('active');
            } else {
                wasdControl.classList.remove('active');
            }

            // Mouse aim highlighting
            const mouseControl = document.getElementById('controlMouse');
            mouseControl.classList.remove('active'); // Always off since it's passive

            // Click to shoot highlighting
            const clickControl = document.getElementById('controlClick');
            if (input.shooting) {
                clickControl.classList.add('active');
            } else {
                clickControl.classList.remove('active');
            }

            // E for auto-fire highlighting
            const eControl = document.getElementById('controlE');
            if (autoFire) {
                eControl.classList.add('active');
            } else {
                eControl.classList.remove('active');
            }

            // I for upgrades highlighting
            const iControl = document.getElementById('controlI');
            if (upgradeMenuVisible) {
                iControl.classList.add('active');
            } else {
                iControl.classList.remove('active');
            }

            // H for help highlighting
            const hControl = document.getElementById('controlH');
            if (showingHelp) {
                hControl.classList.add('active');
            } else {
                hControl.classList.remove('active');
            }
        }

        // Socket events
        socket.on('playerJoined', (data) => {
            playerId = data.id;
            tankTypes = data.tankTypes;
            tankUpgrades = data.tankUpgrades;
            setupUpgradeMenu();
            console.log('Player joined with ID:', playerId);
            console.log('Tank types loaded:', Object.keys(tankTypes).length);
            console.log('Tank upgrades loaded:', Object.keys(tankUpgrades).length);
        });

        socket.on('gameState', (state) => {
            gameState = state;
            
            // Auto-show upgrade menu on level up if player has upgrade points
            if (playerId) {
                const player = state.players.find(p => p.id === playerId);
                if (player) {
                    // Track which tanks the player has used
                    usedTanks.add(player.tankType);
                    
                    if (player.level > lastKnownLevel && player.upgradePoints > 0) {
                        upgradeMenuVisible = true;
                        updateUIVisibility();
                    }
                    lastKnownLevel = player.level;
                }
            }
            
            updateHUD();
            updateLeaderboard();
            
            // Start auto-hide timer for controls help on first game state
            if (!hasMovedOrShot && !helpTimeout) {
                helpTimeout = setTimeout(() => {
                    if (!hasMovedOrShot && !showingHelp) {
                        document.getElementById('controlsHelp').classList.add('hidden');
                    }
                }, 6000);
            }
        });

        // Handle admin verification response
        socket.on('adminVerified', (verified) => {
            if (verified) {
                cheatPanelActive = true;
                document.getElementById('cheatPanel').style.display = 'block';
                console.log('Admin access granted!');
            } else {
                console.log('Admin access denied - incorrect code');
            }
        });

        // Handle player death
        // Handle player death
        socket.on('playerDied', (data) => {
            // Return to main menu on death
            playerId = null;
            gameState = null;
            
            // Tell server to remove this player
            socket.emit('playerLeaveGame');
            
            const deathScreen = document.getElementById('deathScreen');
            const killedByList = document.getElementById('killedByList');
            
            killedByList.innerHTML = '<div class="killed-by">Killed by:</div>';
            
            if (data.killedBy.length === 0) {
                killedByList.innerHTML += '<div class="killer-name">Unknown</div>';
            } else {
                data.killedBy.forEach(killer => {
                    if (killer.type === 'player') {
                        const tankConfig = (tankTypes && tankTypes[killer.tankType]) || {name: 'Basic'};
                        killedByList.innerHTML += `<div class="killer-name">${killer.name} (${tankConfig.name})</div>`;
                    } else if (killer.type === 'polygon') {
                        killedByList.innerHTML += `<div class="killer-name">${killer.name}</div>`;
                    }
                });
            }
            
            deathScreen.classList.add('visible');
            
            // Auto-hide and show menu after 3 seconds
            setTimeout(() => {
                deathScreen.classList.remove('visible');
                document.getElementById('startMenu').classList.remove('hidden');
                document.getElementById('hud').classList.remove('visible');
            }, 3000);
        });

        // Handle AFK kick
        socket.on('afkKick', (data) => {
            playerId = null;
            gameState = null;
            
            const deathScreen = document.getElementById('deathScreen');
            const killedByList = document.getElementById('killedByList');
            
            killedByList.innerHTML = `
                <div class="death-title">KICKED</div>
                <div class="killed-by" style="font-size: 18px; margin-top: 10px;">${data.reason}</div>
            `;
            
            deathScreen.classList.add('visible');
            
            // Auto-hide and show menu after 3 seconds
            setTimeout(() => {
                deathScreen.classList.remove('visible');
                const startMenu = document.getElementById('startMenu');
                if (startMenu) {
                    startMenu.classList.remove('hidden');
                }
            }, 3000);
        });

        // Send input to server
        setInterval(() => {
            if (playerId) {
                input.mouseX = mouseWorldX;
                input.mouseY = mouseWorldY;
                input.shooting = input.shooting || autoFire;
                socket.emit('playerInput', input);
            }
        }, 1000 / 60);

        // Setup button event listeners
        document.getElementById('viewUpgradeTreeBtn').addEventListener('click', () => {
            showUpgradeTree(false);
        });
        
        document.getElementById('viewUpgradeTreeCheat').addEventListener('click', () => {
            showUpgradeTree(true);
        });
        
        document.getElementById('closeUpgradeTreeBtn').addEventListener('click', () => {
            document.getElementById('upgradeTreeModal').style.display = 'none';
        });

        // XP amount control buttons
        let teleportMode = 'all'; // 'all', 'others', or 'you'

        document.getElementById('decreaseXP').addEventListener('click', () => {
            xpAmount = Math.max(1, Math.floor(xpAmount / 2));
            document.getElementById('xpAmount').textContent = xpAmount;
        });

        document.getElementById('increaseXP').addEventListener('click', () => {
            xpAmount = Math.min(1000000, xpAmount * 2);
            document.getElementById('xpAmount').textContent = xpAmount;
        });

        // Teleport mode buttons
        function updateTeleportButtons() {
            document.getElementById('tpModeAll').style.background = teleportMode === 'all' ? '#44ff44' : '#666';
            document.getElementById('tpModeOthers').style.background = teleportMode === 'others' ? '#44ff44' : '#666';
            document.getElementById('tpModeYou').style.background = teleportMode === 'you' ? '#44ff44' : '#666';
        }

        document.getElementById('tpModeAll').addEventListener('click', () => {
            teleportMode = 'all';
            updateTeleportButtons();
        });

        document.getElementById('tpModeOthers').addEventListener('click', () => {
            teleportMode = 'others';
            updateTeleportButtons();
        });

        document.getElementById('tpModeYou').addEventListener('click', () => {
            teleportMode = 'you';
            updateTeleportButtons();
        });

        // Polygon selection buttons
        function updatePolygonDisplay() {
            const polygon = polygonTypes[selectedPolygonIndex];
            document.getElementById('polygonDisplay').textContent = `${polygon.name} (Tier ${polygon.tier})`;
        }

        document.getElementById('prevPolygon').addEventListener('click', () => {
            selectedPolygonIndex = (selectedPolygonIndex - 1 + polygonTypes.length) % polygonTypes.length;
            updatePolygonDisplay();
        });

        document.getElementById('nextPolygon').addEventListener('click', () => {
            selectedPolygonIndex = (selectedPolygonIndex + 1) % polygonTypes.length;
            updatePolygonDisplay();
        });


        // Setup upgrade menu
        function setupUpgradeMenu() {
            const statUpgrades = document.getElementById('statUpgrades');
            
            // Clear existing stat upgrades to prevent duplicates
            statUpgrades.innerHTML = '';
            
            const stats = [
                'healthRegen', 'maxHealth', 'bodyDamage', 'bulletSpeed',
                'bulletPenetration', 'bulletDamage', 'reload', 'movementSpeed'
            ];
            
            const statNames = {
                healthRegen: 'Health Regen',
                maxHealth: 'Max Health',
                bodyDamage: 'Body Damage',
                bulletSpeed: 'Bullet Speed',
                bulletPenetration: 'Bullet Health',
                bulletDamage: 'Bullet Damage',
                reload: 'Reload',
                movementSpeed: 'Movement Speed'
            };

            stats.forEach(stat => {
                const div = document.createElement('div');
                div.className = 'stat-upgrade';
                div.dataset.stat = stat;
                div.innerHTML = `
                    <span>${statNames[stat]}</span>
                    <div class="stat-bars">
                        ${Array(7).fill('<div class="stat-bar"></div>').join('')}
                    </div>
                `;
                div.addEventListener('click', () => {
                    socket.emit('upgradeStat', stat);
                });
                statUpgrades.appendChild(div);
            });
        }

        function updateUpgradeMenu(player) {
            if (!player) return;

            // Update upgrade points display
            const upgradePointsDisplay = document.getElementById('upgradePointsDisplay');
            if (upgradePointsDisplay && player.upgradePoints !== undefined) {
                upgradePointsDisplay.textContent = `Upgrade Points: ${player.upgradePoints}`;
            }

            // Update stat bars
            const stats = [
                'healthRegen', 'maxHealth', 'bodyDamage', 'bulletSpeed',
                'bulletPenetration', 'bulletDamage', 'reload', 'movementSpeed'
            ];

            stats.forEach(stat => {
                const div = document.querySelector(`[data-stat="${stat}"]`);
                if (div) {
                    const bars = div.querySelectorAll('.stat-bar');
                    const level = player.stats ? player.stats[stat] || 0 : 0;
                    
                    // Show up to current level (max 7)
                    bars.forEach((bar, i) => {
                        bar.classList.toggle('filled', i < level);
                    });
                    
                    // Disable if no points available or already at max level
                    div.classList.toggle('maxed', player.upgradePoints <= 0 || level >= 7);
                }
            });

            // Update tank upgrades - only rebuild if tank type changed
            const tankUpgradeSection = document.getElementById('tankUpgradeSection');
            const tankUpgradesDiv = document.getElementById('tankUpgrades');
            const viewUpgradeTreeBtn = document.getElementById('viewUpgradeTreeBtn');
            
            if (tankTypes && player && player.tankType) {
                const currentTank = tankTypes[player.tankType];
                
                // Get available upgrades from tankUpgrades JSON
                const availableUpgrades = tankUpgrades && tankUpgrades[player.tankType] ? tankUpgrades[player.tankType] : [];
                
                if (availableUpgrades && availableUpgrades.length > 0) {
                    tankUpgradeSection.style.display = 'block';
                    viewUpgradeTreeBtn.style.display = 'none'; // Hide button when tank upgrades are shown
                    
                    // Only rebuild if tank type changed
                    if (tankUpgradesDiv.dataset.currentTank !== player.tankType) {
                        tankUpgradesDiv.innerHTML = '';
                        tankUpgradesDiv.dataset.currentTank = player.tankType;
                        
                        availableUpgrades.forEach(tankType => {
                            const tankConfig = tankTypes[tankType];
                            
                            const div = document.createElement('div');
                            div.className = 'tank-upgrade';
                            div.dataset.tankType = tankType;
                            div.dataset.requiredLevel = tankConfig.level;
                            div.innerHTML = `
                                <div class="tank-name">${tankConfig.name}</div>
                                <div class="tank-level">Level ${tankConfig.level}</div>
                            `;
                            
                            div.addEventListener('click', () => {
                                // Get current player state at click time
                                if (!gameState || !playerId) return;
                                const currentPlayer = gameState.players.find(p => p.id === playerId);
                                if (!currentPlayer) return;
                                
                                const canUpgrade = currentPlayer.level >= tankConfig.level;
                                if (canUpgrade) {
                                    console.log('Upgrading to:', tankType);
                                    socket.emit('upgradeTank', tankType);
                                }
                            });
                            
                            tankUpgradesDiv.appendChild(div);
                        });
                    }
                    
                    // Update locked/unlocked state based on current level
                    tankUpgradesDiv.querySelectorAll('.tank-upgrade').forEach(div => {
                        const requiredLevel = parseInt(div.dataset.requiredLevel);
                        const canUpgrade = player.level >= requiredLevel;
                        div.classList.toggle('locked', !canUpgrade);
                    });
                } else {
                    tankUpgradeSection.style.display = 'none';
                    viewUpgradeTreeBtn.style.display = 'block'; // Show button when tank upgrades are hidden
                }
            }
        }

        // Update HUD
        function updateHUD() {
            if (!gameState || !playerId) return;

            const player = gameState.players.find(p => p.id === playerId);
            if (!player) return;

            document.getElementById('score').textContent = Math.floor(player.score);
            document.getElementById('level').textContent = player.level;

            const healthPercent = (player.health / player.maxHealth) * 100;
            document.getElementById('healthFill').style.width = healthPercent + '%';

            const requiredXP = player.level * 100;
            const xpPercent = (player.xp / requiredXP) * 100;
            document.getElementById('xpFill').style.width = xpPercent + '%';

            // Only update upgrade menu if it's currently visible
            if (upgradeMenuVisible) {
                updateUpgradeMenu(player);
            }

            // Update camera FOV based on tank and size
            if (tankTypes && player && player.tankType) {
                const tankConfig = tankTypes[player.tankType];
                const baseFov = tankConfig.fov || 1;
                // Base zoom is higher (more zoomed in) - 1.3x default zoom
                // Player size affects FOV: larger = extra wider view (more than linear)
                const sizeFactor = 1 + (player.size - 20) / 60; // Grows faster with size (was /100)
                setCameraSize((baseFov * sizeFactor) / 1.3); // Divide by 1.3 for more zoom
            }
        }

        // Update leaderboard
        function updateLeaderboard() {
            if (!gameState) return;

            const sorted = [...gameState.players].sort((a, b) => b.score - a.score);
            const list = document.getElementById('leaderboardList');
            
            list.innerHTML = sorted.slice(0, 10).map((player, i) => {
                return `<div class="leaderboard-entry">${i + 1}. ${player.name} - ${Math.floor(player.score)}</div>`;
            }).join('');
        }

        // Upgrade tree visualization
        let usedTanks = new Set(['BASIC']); // Track which tanks the player has used
        let treeViewOffset = { x: 0, y: 0 }; // For panning
        let treeViewZoom = 1; // For zooming
        let treeDragging = false;
        let treeDragStart = { x: 0, y: 0 };
        let hoveredTank = null; // Track which tank is being hovered
        let highlightedPaths = []; // Paths to highlight
        let currentPathIndex = 0; // For alternating between multiple paths
        let pathAlternateInterval = null; // Interval for path alternation
        
        function showUpgradeTree(allowMorphing = false) {
            const modal = document.getElementById('upgradeTreeModal');
            const canvas = document.getElementById('upgradeTreeCanvas');
            modal.style.display = 'block';
            
            // Build tree structure (show hidden tanks when morphing is allowed)
            const treeData = buildTreeStructure(allowMorphing);
            
            // Calculate canvas size based on viewport
            const width = window.innerWidth - 100;
            const height = window.innerHeight - 100;
            canvas.width = width;
            canvas.height = height;
            
            treeViewOffset = { x: width / 2, y: 50 }; // Center horizontally, near top
            treeViewZoom = 1; // Reset zoom
            
            const treeCtx = canvas.getContext('2d');
            
            // Draw the tree
            drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
            
            // Add drag functionality
            setupTreeDrag(canvas, treeCtx, treeData, allowMorphing);
            
            // Add zoom button handlers
            setupTreeZoom(canvas, treeCtx, treeData, allowMorphing);
        }
        
        function setupTreeDrag(canvas, treeCtx, treeData, allowMorphing) {
            canvas.onmousedown = (e) => {
                if (e.button === 0) { // Left click for dragging
                    treeDragging = true;
                    treeDragStart = { x: e.clientX - treeViewOffset.x, y: e.clientY - treeViewOffset.y };
                }
            };
            
            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left - treeViewOffset.x) / treeViewZoom;
                const mouseY = (e.clientY - rect.top - treeViewOffset.y) / treeViewZoom;
                
                if (treeDragging) {
                    treeViewOffset.x = e.clientX - treeDragStart.x;
                    treeViewOffset.y = e.clientY - treeDragStart.y;
                    drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
                } else {
                    // Check for hover
                    const { nodePositions } = buildTreeLayout(treeData);
                    let newHoveredTank = null;
                    
                    for (const tankKey in nodePositions) {
                        const pos = nodePositions[tankKey];
                        const dist = Math.sqrt((mouseX - pos.x) ** 2 + (mouseY - pos.y) ** 2);
                        
                        if (dist < 30) {
                            newHoveredTank = tankKey;
                            break;
                        }
                    }
                    
                    // If hover changed, update paths
                    if (newHoveredTank !== hoveredTank) {
                        hoveredTank = newHoveredTank;
                        
                        if (hoveredTank) {
                            // Find all paths to this tank
                            highlightedPaths = findAllPaths('BASIC', hoveredTank, treeData.upgrades);
                            currentPathIndex = 0;
                            
                            // Start alternating if multiple paths
                            if (pathAlternateInterval) clearInterval(pathAlternateInterval);
                            if (highlightedPaths.length > 1) {
                                pathAlternateInterval = setInterval(() => {
                                    currentPathIndex = (currentPathIndex + 1) % highlightedPaths.length;
                                    drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
                                }, 1000);
                            }
                        } else {
                            highlightedPaths = [];
                            if (pathAlternateInterval) {
                                clearInterval(pathAlternateInterval);
                                pathAlternateInterval = null;
                            }
                        }
                        
                        drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
                    }
                }
            };
            
            canvas.onmouseup = () => {
                treeDragging = false;
            };
            
            canvas.onmouseleave = () => {
                treeDragging = false;
            };
            
            // Right-click for morphing
            if (allowMorphing) {
                canvas.oncontextmenu = (e) => {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const clickX = (e.clientX - rect.left - treeViewOffset.x) / treeViewZoom;
                    const clickY = (e.clientY - rect.top - treeViewOffset.y) / treeViewZoom;
                    
                    const { nodePositions } = buildTreeLayout(treeData);
                    
                    for (const tankKey in nodePositions) {
                        const pos = nodePositions[tankKey];
                        const dist = Math.sqrt((clickX - pos.x) ** 2 + (clickY - pos.y) ** 2);
                        
                        if (dist < 30) {
                            // In cheat mode, use cheatMorphTank instead of upgradeTank
                            socket.emit('cheatMorphTank', tankKey);
                            usedTanks.add(tankKey);
                            drawUpgradeTree(treeCtx, treeData, true, canvas);
                            break;
                        }
                    }
                };
            }
        }
        
        function setupTreeZoom(canvas, treeCtx, treeData, allowMorphing) {
            // Zoom in button
            document.getElementById('zoomInTreeBtn').onclick = () => {
                treeViewZoom *= 1.2;
                drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
            };
            
            // Zoom out button
            document.getElementById('zoomOutTreeBtn').onclick = () => {
                treeViewZoom /= 1.2;
                drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
            };
            
            // Reset button
            document.getElementById('resetTreeBtn').onclick = () => {
                treeViewOffset = { x: canvas.width / 2, y: 50 };
                treeViewZoom = 1;
                drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
            };
            
            // Mouse wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                treeViewZoom *= zoomFactor;
                drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
            }, { passive: false });
        }
        
        // Find all upgrade paths from start to end tank
        function findAllPaths(start, end, upgrades) {
            if (start === end) return [[start]];
            
            const allPaths = [];
            
            function dfs(current, target, path, visited) {
                if (current === target) {
                    allPaths.push([...path]);
                    return;
                }
                
                const nextTanks = upgrades[current] || [];
                for (const next of nextTanks) {
                    if (!visited.has(next)) {
                        visited.add(next);
                        path.push(next);
                        dfs(next, target, path, visited);
                        path.pop();
                        visited.delete(next);
                    }
                }
            }
            
            dfs(start, end, [start], new Set([start]));
            return allPaths;
        }
        
        function buildTreeStructure(showHiddenTanks = false) {
            if (!tankUpgrades || !tankTypes) return null;
            
            const levels = {};
            
            // Group tanks by level (optionally include hidden tanks)
            for (const tankKey in tankTypes) {
                const tank = tankTypes[tankKey];
                if (!showHiddenTanks && tank.hideFromTree) continue; // Skip hidden tanks unless requested
                const level = tank.level;
                if (!levels[level]) levels[level] = [];
                levels[level].push(tankKey);
            }
            
            return { levels, upgrades: tankUpgrades };
        }
        
        function buildTreeLayout(treeData) {
            const { levels } = treeData;
            const levelKeys = Object.keys(levels).map(Number).sort((a, b) => a - b);
            
            const nodeSpacing = 150;
            const levelSpacing = 200;
            const startX = 0;
            const startY = 0;
            
            const nodePositions = {};
            
            // Calculate positions for each tank
            levelKeys.forEach((level, levelIndex) => {
                const tanksAtLevel = levels[level];
                const totalWidth = tanksAtLevel.length * nodeSpacing;
                const levelY = startY + levelIndex * levelSpacing;
                
                tanksAtLevel.forEach((tankKey, tankIndex) => {
                    const x = startX + tankIndex * nodeSpacing - totalWidth / 2;
                    const y = levelY;
                    nodePositions[tankKey] = { x, y };
                });
            });
            
            return { nodePositions };
        }
        
        function drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas) {
            if (!treeData || !tankTypes) return;
            
            const { upgrades } = treeData;
            const { nodePositions } = buildTreeLayout(treeData);
            
            // Clear canvas
            treeCtx.fillStyle = '#2a2a2a';
            treeCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            treeCtx.save();
            treeCtx.translate(treeViewOffset.x, treeViewOffset.y);
            treeCtx.scale(treeViewZoom, treeViewZoom); // Apply zoom
            
            // Draw connections first
            treeCtx.lineWidth = 3 / treeViewZoom; // Adjust line width for zoom
            
            // Get current path to highlight
            const currentPath = highlightedPaths.length > 0 ? highlightedPaths[currentPathIndex] : [];
            const pathSet = new Set();
            for (let i = 0; i < currentPath.length - 1; i++) {
                pathSet.add(`${currentPath[i]}->${currentPath[i + 1]}`);
            }
            
            for (const fromTank in upgrades) {
                const toTanks = upgrades[fromTank];
                if (!nodePositions[fromTank]) continue;
                
                toTanks.forEach(toTank => {
                    if (!nodePositions[toTank]) return;
                    
                    const isInPath = pathSet.has(`${fromTank}->${toTank}`);
                    
                    // Check if both ends have been used
                    const fromUsed = usedTanks.has(fromTank);
                    const toUsed = usedTanks.has(toTank);
                    
                    if (isInPath) {
                        // Glowing effect for highlighted path
                        treeCtx.strokeStyle = '#ffff00';
                        treeCtx.lineWidth = 6 / treeViewZoom;
                        treeCtx.shadowBlur = 15;
                        treeCtx.shadowColor = '#ffff00';
                    } else if (fromUsed && toUsed) {
                        treeCtx.strokeStyle = '#aaa'; // Brighter
                        treeCtx.lineWidth = 3 / treeViewZoom;
                        treeCtx.shadowBlur = 0;
                    } else {
                        treeCtx.strokeStyle = '#555'; // Normal
                        treeCtx.lineWidth = 3 / treeViewZoom;
                        treeCtx.shadowBlur = 0;
                    }
                    
                    treeCtx.beginPath();
                    treeCtx.moveTo(nodePositions[fromTank].x, nodePositions[fromTank].y + 30);
                    treeCtx.lineTo(nodePositions[toTank].x, nodePositions[toTank].y - 30);
                    treeCtx.stroke();
                });
            }
            
            // Reset shadow
            treeCtx.shadowBlur = 0;
            
            // Draw nodes
            for (const tankKey in nodePositions) {
                const pos = nodePositions[tankKey];
                const tank = tankTypes[tankKey];
                const isUsed = usedTanks.has(tankKey);
                
                drawTankPreview(treeCtx, tank, pos.x, pos.y, isUsed);
                
                // Draw name below tank
                treeCtx.fillStyle = isUsed ? '#fff' : '#888';
                treeCtx.font = 'bold 14px Arial';
                treeCtx.textAlign = 'center';
                treeCtx.fillText(tank.name, pos.x, pos.y + 55);
            }
            
            treeCtx.restore();
        }
        
        function drawTankPreview(ctx, tankConfig, x, y, isUsed) {
            ctx.save();
            ctx.translate(x, y);
            
            const scale = 0.8;
            const baseSize = 30 * scale;
            
            // Draw guns first (layer 0)
            if (tankConfig.guns) {
                tankConfig.guns.forEach(gun => {
                    const gunAngle = (gun.angle || 0) * Math.PI / 180;
                    const offsetY = (gun.offsetY || 0) * scale;
                    const offsetX = (gun.offsetX || 0) * scale;
                    
                    ctx.save();
                    ctx.rotate(gunAngle);
                    ctx.translate(offsetX, offsetY);
                    
                    if (gun.type === 'normal') {
                        const gunLength = (gun.length || 1) * 20 * scale;
                        const gunWidth = (gun.size || 1) * 20 * scale;
                        
                        ctx.fillStyle = '#999';
                        ctx.fillRect(baseSize - 5 * scale, -gunWidth / 2, gunLength, gunWidth);
                        ctx.strokeStyle = '#404040';
                        ctx.lineWidth = 1.5;
                        ctx.strokeRect(baseSize - 5 * scale, -gunWidth / 2, gunLength, gunWidth);
                    } else if (gun.type === 'trap') {
                        const trapSize = 15 * scale;
                        ctx.fillStyle = '#999';
                        ctx.fillRect(baseSize - 3 * scale, -trapSize / 2, trapSize, trapSize);
                        ctx.strokeStyle = '#404040';
                        ctx.lineWidth = 1.5;
                        ctx.strokeRect(baseSize - 3 * scale, -trapSize / 2, trapSize, trapSize);
                    } else if (gun.type === 'minion') {
                        // Draw thin trapezoid for minion spawner - wide side facing out
                        const length = 25 * scale;
                        const baseWidth = 8 * scale; // Narrow end (at tank)
                        const tipWidth = 18 * scale; // Wide end (facing out)
                        const baseX = baseSize - 5 * scale;
                        
                        ctx.fillStyle = '#999';
                        ctx.strokeStyle = '#404040';
                        ctx.lineWidth = 1.5;
                        
                        ctx.beginPath();
                        ctx.moveTo(baseX, -baseWidth / 2); // Back top corner (narrow base)
                        ctx.lineTo(baseX + length, -tipWidth / 2); // Front top corner (wide tip)
                        ctx.lineTo(baseX + length, tipWidth / 2); // Front bottom corner (wide tip)
                        ctx.lineTo(baseX, baseWidth / 2); // Back bottom corner (narrow base)
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                });
            }
            
            // Draw base shape
            if (tankConfig.baseShape === 'blade' || tankConfig.baseShape === 'blade_twin') {
                // Draw blade/smasher shape with grey polygon base
                const bladeShape = tankConfig.bladeShape || 'square';
                const bladeCount = tankConfig.bladeCount || 1;
                const bladeSize = tankConfig.bladeSize || 1.35;
                
                let baseSides = 4; // Default square
                if (bladeShape === 'triangle') baseSides = 3;
                else if (bladeShape === 'square') baseSides = 4;
                else if (bladeShape === 'pentagon') baseSides = 5;
                else if (bladeShape === 'hexagon') baseSides = 6;
                else if (bladeShape === 'octagon') baseSides = 8;
                
                // Draw multiple blade layers
                for (let layer = 0; layer < bladeCount; layer++) {
                    const layerRotation = (layer / bladeCount) * (Math.PI / baseSides);
                    const layerSize = baseSize * bladeSize * (1 - layer * 0.15);
                    
                    ctx.save();
                    ctx.rotate(layerRotation);
                    
                    ctx.fillStyle = '#999';
                    ctx.beginPath();
                    for (let i = 0; i < baseSides; i++) {
                        const angle = (i / baseSides) * Math.PI * 2 - Math.PI / 2;
                        const x = Math.cos(angle) * layerSize;
                        const y = Math.sin(angle) * layerSize;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#404040';
                    ctx.lineWidth = 2.5;
                    ctx.stroke();
                    
                    ctx.restore();
                }
                
                // Draw outer colored circles (baseLayers support)
                const baseLayers = tankConfig.baseLayers;
                const circleColors = isUsed ? ['#00B2E1', '#0099C9'] : ['#444', '#333'];
                
                if (Array.isArray(baseLayers)) {
                    // Custom layer configuration for preview
                    baseLayers.forEach((layer, i) => {
                        const layerSize = baseSize * (layer.size || 1.0);
                        const layerColor = layer.color || circleColors[i % circleColors.length];
                        const sides = layer.sides || 0;
                        const stretch = layer.stretch || { x: 1, y: 1 };
                        
                        ctx.save();
                        ctx.scale(stretch.x, stretch.y);
                        ctx.fillStyle = layerColor;
                        
                        if (sides === 0) {
                            ctx.beginPath();
                            ctx.arc(0, 0, layerSize, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            ctx.beginPath();
                            for (let j = 0; j < sides; j++) {
                                const angle = (j / sides) * Math.PI * 2 - Math.PI / 2;
                                const x = Math.cos(angle) * layerSize;
                                const y = Math.sin(angle) * layerSize;
                                if (j === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        ctx.restore();
                    });
                } else {
                    // Default circular layers
                    const circleSizes = [baseSize * 1.1, baseSize * 0.7];
                    circleColors.forEach((color, i) => {
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(0, 0, circleSizes[i], 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
            } else {
                // Draw circle base
                ctx.fillStyle = isUsed ? '#00a2ff' : '#444';
                ctx.beginPath();
                ctx.arc(0, 0, baseSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = isUsed ? '#fff' : '#666';
                ctx.lineWidth = 2.5;
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // Drawing functions
        function drawGrid() {
            try {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)'; // Lighter grid lines
                ctx.lineWidth = 1;

                const startX = Math.floor((camera.x - canvas.width / 2 / camera.zoom) / GRID_SIZE) * GRID_SIZE;
                const startY = Math.floor((camera.y - canvas.height / 2 / camera.zoom) / GRID_SIZE) * GRID_SIZE;
                const endX = camera.x + canvas.width / 2 / camera.zoom;
                const endY = camera.y + canvas.height / 2 / camera.zoom;

                for (let x = startX; x <= endX; x += GRID_SIZE) {
                    const screen = worldToScreen(x, 0);
                    ctx.beginPath();
                    ctx.moveTo(screen.x, 0);
                    ctx.lineTo(screen.x, canvas.height);
                    ctx.stroke();
                }

                for (let y = startY; y <= endY; y += GRID_SIZE) {
                    const screen = worldToScreen(0, y);
                    ctx.beginPath();
                    ctx.moveTo(0, screen.y);
                    ctx.lineTo(canvas.width, screen.y);
                    ctx.stroke();
                }
            } catch (e) {
                console.error('Error drawing grid:', e);
            }
        }

        function drawMapBorder() {
            const center = worldToScreen(0, 0);
            const radius = MAP_RADIUS * camera.zoom;

            ctx.strokeStyle = '#555';
            ctx.lineWidth = 10;
            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
            ctx.stroke();

            // Fill outside the circle
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawPolygon(poly) {
            const screen = worldToScreen(poly.x, poly.y);
            
            // Apply death animation: grow 20% and fade out
            let size = poly.size * camera.zoom;
            let alpha = 1;
            
            if (poly.dying) {
                const progress = poly.deathProgress || 0;
                // Grow from baseSize to baseSize * 1.2
                const growthFactor = 1 + (progress * 0.2);
                size = poly.baseSize * camera.zoom * growthFactor;
                // Fade from 1 to 0
                alpha = 1 - progress;
            }

            ctx.save();
            ctx.translate(screen.x, screen.y);
            ctx.rotate(poly.rotation);
            ctx.globalAlpha = alpha;

            // Create darker outline color (darker shade of fill color)
            const fillColor = poly.color;
            const outlineColor = darkenColor(fillColor, 0.3);

            ctx.fillStyle = fillColor;
            ctx.strokeStyle = outlineColor;
            ctx.lineWidth = 4 * camera.zoom;

            ctx.beginPath();
            for (let i = 0; i < poly.sides; i++) {
                const angle = (i / poly.sides) * Math.PI * 2;
                const x = Math.cos(angle) * size;
                const y = Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore();
            
            // Draw health bar if toggle is on or if damaged
            if (showAllHealthBars && !poly.dying && poly.health !== undefined && poly.maxHealth !== undefined) {
                const healthPercent = poly.health / poly.maxHealth;
                const barWidth = size * 2;
                const barHeight = 4 * camera.zoom;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);
                
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth * healthPercent, barHeight);
                
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.strokeRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);
            } else if (!poly.dying && poly.health < poly.maxHealth) {
                // Show health bar when damaged even if toggle is off
                const barWidth = size * 2;
                const barHeight = 5 * camera.zoom;
                const healthPercent = poly.health / poly.maxHealth;
                
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 15 * camera.zoom, barWidth, barHeight);

                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 15 * camera.zoom, barWidth * healthPercent, barHeight);
                ctx.restore();
            }
        }
        
        // Helper function to darken colors
        function darkenColor(color, factor) {
            // Convert hex to RGB
            const hex = color.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            // Darken
            const newR = Math.floor(r * (1 - factor));
            const newG = Math.floor(g * (1 - factor));
            const newB = Math.floor(b * (1 - factor));
            
            // Convert back to hex
            return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
        }

        function drawTank(player) {
            // Don't draw if tank types haven't loaded yet
            if (!tankTypes) return;
            
            const screen = worldToScreen(player.x, player.y);
            const size = player.size * camera.zoom;
            
            // Calculate size multiplier based on level (player.size grows with level)
            const baseTankSize = 20; // Base size at level 0
            const sizeMultiplier = player.size / baseTankSize;

            ctx.save();
            ctx.translate(screen.x, screen.y);
            ctx.rotate(player.rotation); // Rotate entire tank

            // Get tank config
            const tankConfig = tankTypes[player.tankType];
            
            if (!tankConfig) {
                // Fallback: draw simple tank if config not loaded
                const baseColor = player.id === playerId ? '#00B2E1' : '#F14E54';
                ctx.fillStyle = baseColor;
                ctx.strokeStyle = darkenColor(baseColor, 0.3);
                ctx.lineWidth = 3 * camera.zoom;
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Simple gun
                ctx.fillStyle = '#999';
                ctx.strokeStyle = '#404040';
                ctx.lineWidth = 2 * camera.zoom;
                ctx.fillRect(size - 5 * camera.zoom, -10 * camera.zoom, 20 * camera.zoom, 20 * camera.zoom);
                ctx.strokeRect(size - 5 * camera.zoom, -10 * camera.zoom, 20 * camera.zoom, 20 * camera.zoom);
                
                ctx.restore();
                return;
            }

            // Collect all drawable elements with layers (like editor)
            const drawables = [];
            
            // Add base shape (layer determined by baseShape type or baseBlocks)
            if (tankConfig.baseBlocks && tankConfig.baseBlocks.length > 0) {
                // Advanced base with custom base blocks
                tankConfig.baseBlocks.forEach(baseBlock => {
                    drawables.push({ type: 'baseBlock', layer: baseBlock.layer || 0, data: baseBlock });
                });
            } else {
                // Simple base (single shape) - always layer 0
                drawables.push({ type: 'base', layer: 0, data: tankConfig });
            }
            
            // Add blades
            if (tankConfig.blades) {
                tankConfig.blades.forEach(blade => {
                    drawables.push({ type: 'blade', layer: blade.layer || 0, data: blade });
                });
            }
            
            // Add guns
            if (tankConfig.guns) {
                tankConfig.guns.forEach((gun, gunIndex) => {
                    drawables.push({ type: 'gun', layer: gun.layer || 0, data: gun, index: gunIndex });
                });
            }
            
            // Sort by layer (lower = behind, higher = in front)
            drawables.sort((a, b) => a.layer - b.layer);
            
            // Render all elements in layer order
            drawables.forEach(drawable => {
                if (drawable.type === 'gun') {
                    renderGun(drawable.data, drawable.index, player, size, sizeMultiplier);
                } else if (drawable.type === 'base') {
                    renderBase(drawable.data, player, size, sizeMultiplier);
                } else if (drawable.type === 'baseBlock') {
                    renderBaseBlock(drawable.data, player, size, sizeMultiplier);
                } else if (drawable.type === 'blade') {
                    renderBlade(drawable.data, player, size, sizeMultiplier);
                }
            });

            ctx.restore();

            // Name and health bar (outside rotation)
            ctx.font = `${14 * camera.zoom}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.strokeText(player.name, screen.x, screen.y - size - 20 * camera.zoom);
            ctx.fillText(player.name, screen.x, screen.y - size - 20 * camera.zoom);

            // Health bar
            const barWidth = size * 2.5;
            const barHeight = 8 * camera.zoom;
            const healthPercent = player.health / player.maxHealth;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);

            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth * healthPercent, barHeight);

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.strokeRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);
        }
        
        // Helper function to render a gun
        function renderGun(gun, gunIndex, player, size, sizeMultiplier) {
            const recoilOffset = (player.gunRecoils && player.gunRecoils[`gun_${gunIndex}`]) || 0;
            
            const gunAngle = (gun.angle || 0) * Math.PI / 180;
            const offsetY = (gun.offsetY || 0) * camera.zoom * sizeMultiplier;
            const offsetX = (gun.offsetX || 0) * camera.zoom * sizeMultiplier;

            ctx.save();
            
            // Check if gun has baked rotation (from advanced base export) or needs calculation
            if (gun.rotation !== undefined && gun.blockRotation === undefined && gun.selfAngle === undefined) {
                // Baked gun: angle=0, position in offsets, rotation is final
                const rotation = gun.rotation * Math.PI / 180;
                ctx.rotate(rotation);
                ctx.translate(offsetX, offsetY);
            } else {
                // Normal gun: calculate position and rotation from angle
                const blockRotation = (gun.blockRotation || 0) * Math.PI / 180;
                const selfAngle = (gun.selfAngle || 0) * Math.PI / 180;
                
                // Get radius and face angle at this position
                const { radius: baseRadius, faceAngle } = getBaseRadiusAndFaceAtAngle(player, gunAngle);
                const gunDistance = baseRadius * camera.zoom;
                
                // Position gun on perimeter at 'angle'
                ctx.rotate(gunAngle);
                ctx.translate(gunDistance, 0);
                
                // Rotate to align with face (perpendicular to surface)
                ctx.rotate(faceAngle - gunAngle);
                
                // Apply additional rotations
                ctx.rotate(blockRotation + selfAngle);
                ctx.translate(offsetX, offsetY);
            }

            const gunColor = gun.color || '#999';
            ctx.fillStyle = gunColor;
            ctx.strokeStyle = '#404040';
            ctx.lineWidth = 2 * camera.zoom;
            
            const recoilX = -recoilOffset * camera.zoom * sizeMultiplier;
            
            if (gun.type === 'normal') {
                const gunLength = (gun.length || 1) * 20 * camera.zoom * sizeMultiplier;
                const gunWidth = (gun.size || 1) * 20 * camera.zoom * sizeMultiplier;
                
                ctx.fillRect(-5 * camera.zoom + recoilX, -gunWidth / 2, gunLength, gunWidth);
                ctx.strokeRect(-5 * camera.zoom + recoilX, -gunWidth / 2, gunLength, gunWidth);
            } else if (gun.type === 'trap') {
                const baseLength = 20 * camera.zoom * sizeMultiplier;
                const baseHeight = 20 * camera.zoom * sizeMultiplier;
                const flatRectWidth = 30 * camera.zoom * sizeMultiplier;
                const flatRectHeight = 8 * camera.zoom * sizeMultiplier;
                
                // Base rectangle (horizontal part of rotated T)
                ctx.fillRect(-5 * camera.zoom * sizeMultiplier + recoilX, -baseHeight / 2, baseLength, baseHeight);
                ctx.strokeRect(-5 * camera.zoom * sizeMultiplier + recoilX, -baseHeight / 2, baseLength, baseHeight);
                
                // Front flat rectangle (vertical part of rotated T)
                ctx.fillRect(-5 * camera.zoom * sizeMultiplier + baseLength + recoilX, -flatRectWidth / 2, flatRectHeight, flatRectWidth);
                ctx.strokeRect(-5 * camera.zoom * sizeMultiplier + baseLength + recoilX, -flatRectWidth / 2, flatRectHeight, flatRectWidth);
            } else if (gun.type === 'minion') {
                const length = 25 * camera.zoom * sizeMultiplier;
                const baseWidth = 8 * camera.zoom * sizeMultiplier;
                const tipWidth = 18 * camera.zoom * sizeMultiplier;
                
                ctx.beginPath();
                ctx.moveTo(-5 * camera.zoom + recoilX, -baseWidth / 2);
                ctx.lineTo(-5 * camera.zoom + length + recoilX, -tipWidth / 2);
                ctx.lineTo(-5 * camera.zoom + length + recoilX, tipWidth / 2);
                ctx.lineTo(-5 * camera.zoom + recoilX, baseWidth / 2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            ctx.restore();
        }
        
        // Helper function to render base shape
        function renderBase(tankConfig, player, size, sizeMultiplier) {
            if (tankConfig.baseShape === 'blade' || tankConfig.baseShape === 'blade_twin') {
                // Blade tank (like Smasher)
                const bladeShape = tankConfig.bladeShape || 'square';
                const bladeCount = tankConfig.bladeCount || 1;
                const bladeSize = tankConfig.bladeSize || 1.35;
                
                let baseSides = 4;
                if (bladeShape === 'triangle') baseSides = 3;
                else if (bladeShape === 'square') baseSides = 4;
                else if (bladeShape === 'pentagon') baseSides = 5;
                else if (bladeShape === 'hexagon') baseSides = 6;
                else if (bladeShape === 'octagon') baseSides = 8;
                
                // Draw multiple blade layers
                for (let layer = 0; layer < bladeCount; layer++) {
                    const layerRotation = (layer / bladeCount) * (Math.PI / baseSides);
                    const layerSize = size * bladeSize * (1 - layer * 0.15);
                    
                    ctx.save();
                    ctx.rotate(layerRotation);
                    
                    ctx.fillStyle = '#999';
                    ctx.strokeStyle = '#404040';
                    ctx.lineWidth = 3 * camera.zoom;
                    ctx.beginPath();
                    for (let i = 0; i < baseSides; i++) {
                        const angle = (i / baseSides) * Math.PI * 2 - Math.PI / 2;
                        const x = Math.cos(angle) * layerSize;
                        const y = Math.sin(angle) * layerSize;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                }

                // Draw center circles
                const baseLayers = tankConfig.baseLayers || 1;
                const circleColors = player.id === playerId ? 
                    ['#00B2E1', '#0099C9', '#0080B0'] : 
                    ['#F14E54', '#D9444A', '#C03A40'];
                
                if (Array.isArray(baseLayers)) {
                    baseLayers.forEach((layer, i) => {
                        const layerSize = size * (layer.size || 1.0);
                        const layerColor = layer.color || circleColors[i % circleColors.length];
                        const sides = layer.sides || 0;
                        const stretch = layer.stretch || { x: 1, y: 1 };
                        const position = layer.position || { x: 0, y: 0 };
                        
                        ctx.save();
                        ctx.translate(position.x * camera.zoom, position.y * camera.zoom);
                        ctx.scale(stretch.x, stretch.y);
                        
                        ctx.fillStyle = layerColor;
                        ctx.strokeStyle = darkenColor(layerColor, 0.3);
                        ctx.lineWidth = 3 * camera.zoom;
                        
                        if (sides === 0) {
                            ctx.beginPath();
                            ctx.arc(0, 0, layerSize, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                        } else {
                            ctx.beginPath();
                            for (let i = 0; i < sides; i++) {
                                const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                                const x = Math.cos(angle) * layerSize;
                                const y = Math.sin(angle) * layerSize;
                                if (i === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                    });
                } else if (typeof baseLayers === 'number') {
                    let circleSizes;
                    if (baseLayers === 2) {
                        circleSizes = [size * 1.1, size * 0.75];
                    } else if (baseLayers >= 3) {
                        circleSizes = [size * 1.1, size * 0.85, size * 0.6];
                    } else {
                        circleSizes = [size * 1.1, size * 0.85, size * 0.6];
                    }
                    
                    circleSizes.slice(0, Math.max(baseLayers, 1)).forEach((circleSize, i) => {
                        const color = circleColors[i % circleColors.length];
                        ctx.fillStyle = color;
                        ctx.strokeStyle = darkenColor(color, 0.3);
                        ctx.lineWidth = 3 * camera.zoom;
                        ctx.beginPath();
                        ctx.arc(0, 0, circleSize, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    });
                } else {
                    const color = circleColors[0];
                    ctx.fillStyle = color;
                    ctx.strokeStyle = darkenColor(color, 0.3);
                    ctx.lineWidth = 3 * camera.zoom;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 1.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
            } else if (typeof tankConfig.baseShape === 'number' && tankConfig.baseShape >= 3) {
                // Polygon base
                const sides = tankConfig.baseShape;
                const baseColor = player.id === playerId ? '#00B2E1' : '#F14E54';
                ctx.fillStyle = baseColor;
                ctx.strokeStyle = darkenColor(baseColor, 0.3);
                ctx.lineWidth = 3 * camera.zoom;
                ctx.beginPath();
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                    const x = Math.cos(angle) * size;
                    const y = Math.sin(angle) * size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            } else if (tankConfig.baseShape !== 'advanced') {
                // Default circular base
                const baseColor = player.id === playerId ? '#00B2E1' : '#F14E54';
                ctx.fillStyle = baseColor;
                ctx.strokeStyle = darkenColor(baseColor, 0.3);
                ctx.lineWidth = 3 * camera.zoom;
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
        }
        
        // Helper function to render a base block
        function renderBaseBlock(baseBlock, player, size, sizeMultiplier) {
            ctx.save();
            ctx.translate(baseBlock.x * camera.zoom * sizeMultiplier, baseBlock.y * camera.zoom * sizeMultiplier);
            ctx.rotate((baseBlock.rotation || 0) * Math.PI / 180);
            
            const blockColor = baseBlock.color || (player.id === playerId ? '#00B2E1' : '#F14E54');
            ctx.fillStyle = blockColor;
            ctx.strokeStyle = darkenColor(blockColor, 0.3);
            ctx.lineWidth = 3 * camera.zoom;
            
            if (baseBlock.shape === 0) {
                // Circle
                const radius = (baseBlock.size + (baseBlock.width || 0)) * camera.zoom * sizeMultiplier;
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            } else if (baseBlock.shape === 4 && (baseBlock.width || baseBlock.height)) {
                // Rectangle
                const totalWidth = (baseBlock.size + (baseBlock.width || 0)) * camera.zoom * sizeMultiplier;
                const totalHeight = (baseBlock.size + (baseBlock.height || 0)) * camera.zoom * sizeMultiplier;
                ctx.beginPath();
                ctx.rect(-totalWidth/2, -totalHeight/2, totalWidth, totalHeight);
                ctx.fill();
                ctx.stroke();
            } else {
                // Polygon
                const sides = baseBlock.shape;
                const radiusX = (baseBlock.size + (baseBlock.width || 0)) * camera.zoom * sizeMultiplier;
                const radiusY = (baseBlock.size + (baseBlock.height || 0)) * camera.zoom * sizeMultiplier;
                ctx.beginPath();
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                    const x = Math.cos(angle) * radiusX;
                    const y = Math.sin(angle) * radiusY;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        // Helper function to render a blade
        function renderBlade(blade, player, size, sizeMultiplier) {
            ctx.save();
            ctx.translate(blade.x * camera.zoom * sizeMultiplier, blade.y * camera.zoom * sizeMultiplier);
            ctx.rotate((blade.rotation || 0) * Math.PI / 180);
            
            const bladeSize = blade.size * size;
            const sides = blade.shape;
            
            ctx.fillStyle = blade.color || '#999999';
            ctx.strokeStyle = darkenColor(blade.color || '#999999', 0.3);
            ctx.lineWidth = 3 * camera.zoom;
            
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                const x = Math.cos(angle) * bladeSize;
                const y = Math.sin(angle) * bladeSize;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
        }

        function drawBullet(bullet) {
            const screen = worldToScreen(bullet.x, bullet.y);
            
            // Apply death animation: shrink and fade out with particle effect
            let size = bullet.size * camera.zoom;
            let alpha = 1;
            
            if (bullet.dying) {
                const progress = bullet.deathProgress || 0;
                // Shrink from size to 0
                size = bullet.size * camera.zoom * (1 - progress);
                // Fade from 1 to 0
                alpha = 1 - progress;
                
                // Draw explosion particles
                const particleCount = 8;
                const particleSize = 3 * camera.zoom;
                const maxDist = 15 * camera.zoom * progress;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const dist = maxDist * (0.5 + Math.random() * 0.5);
                    const px = screen.x + Math.cos(angle) * dist;
                    const py = screen.y + Math.sin(angle) * dist;
                    
                    ctx.fillStyle = '#00B2E1';
                    ctx.beginPath();
                    ctx.arc(px, py, particleSize * (1 - progress * 0.5), 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            ctx.save();
            ctx.globalAlpha = alpha;
            const bulletColor = '#00B2E1';
            ctx.fillStyle = bulletColor;
            ctx.strokeStyle = darkenColor(bulletColor, 0.3);
            ctx.lineWidth = 2 * camera.zoom;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, size, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
            
            // Draw health bar if toggle is on
            if (showAllHealthBars && bullet.health !== undefined && bullet.maxHealth !== undefined) {
                const healthPercent = bullet.health / bullet.maxHealth;
                const barWidth = size * 2;
                const barHeight = 4 * camera.zoom;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);
                
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth * healthPercent, barHeight);
                
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.strokeRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);
            }
        }

        function drawTrap(trap) {
            const screen = worldToScreen(trap.x, trap.y);
            let size = trap.size * camera.zoom;
            
            // Death animation - shrink and fade
            let alpha = 1;
            if (trap.dying) {
                const progress = trap.deathProgress || 0;
                size *= (1 - progress);
                alpha = 1 - progress;
                if (progress >= 1) return; // Don't draw if animation complete
            }

            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(screen.x, screen.y);
            ctx.rotate(trap.rotation);

            // Blue for own traps, red for enemy traps
            const isOwn = trap.owner === playerId;
            const trapColor = isOwn ? '#00B2E1' : '#FE7C6D';
            ctx.fillStyle = trapColor;
            ctx.strokeStyle = darkenColor(trapColor, 0.3);
            ctx.lineWidth = 3 * camera.zoom;

            ctx.beginPath();
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                const x = Math.cos(angle) * size;
                const y = Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore();
            
            // Draw health bar if toggle is on and not dying
            if (!trap.dying && showAllHealthBars && trap.health !== undefined && trap.maxHealth !== undefined) {
                const healthPercent = trap.health / trap.maxHealth;
                const barWidth = size * 2.5;
                const barHeight = 4 * camera.zoom;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);
                
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth * healthPercent, barHeight);
                
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.strokeRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);
            }
        }

        function drawMinion(minion) {
            const screen = worldToScreen(minion.x, minion.y);
            let size = minion.size * camera.zoom;
            
            // Death animation - shrink and fade
            let alpha = 1;
            if (minion.dying) {
                const progress = minion.deathProgress || 0;
                size *= (1 - progress);
                alpha = 1 - progress;
                if (progress >= 1) return; // Don't draw if animation complete
            }

            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(screen.x, screen.y);
            ctx.rotate(minion.rotation);

            // Draw triangle base
            const minionColor = '#00B2E1';
            ctx.fillStyle = minionColor;
            ctx.strokeStyle = darkenColor(minionColor, 0.3);
            ctx.lineWidth = 2 * camera.zoom;

            ctx.beginPath();
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2 - Math.PI / 2;
                const x = Math.cos(angle) * size;
                const y = Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore();
            
            // Draw health bar if toggle is on and not dying
            if (!minion.dying && showAllHealthBars && minion.health !== undefined && minion.maxHealth !== undefined) {
                const healthPercent = minion.health / minion.maxHealth;
                const barWidth = size * 2.5;
                const barHeight = 4 * camera.zoom;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);
                
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth * healthPercent, barHeight);
                
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.strokeRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);
            }
        }

        // Helper function to check if object is in viewport
        function isInViewport(obj, size = 50) {
            const screen = worldToScreen(obj.x, obj.y);
            const margin = size * camera.zoom + 100; // Extra margin for safety
            
            return screen.x > -margin && screen.x < canvas.width + margin &&
                   screen.y > -margin && screen.y < canvas.height + margin;
        }

        // Draw minimap
        function drawMinimap() {
            const minimapCanvas = document.getElementById('minimap');
            if (!minimapCanvas || !gameState || !playerId) return;
            
            const minimapCtx = minimapCanvas.getContext('2d');
            const minimapSize = 150;
            const center = minimapSize / 2;
            const mapRadius = 3000; // Game map radius
            const minimapScale = center / mapRadius; // Scale from game units to minimap pixels
            
            // Clear minimap
            minimapCtx.clearRect(0, 0, minimapSize, minimapSize);
            
            // Draw map circle background
            minimapCtx.fillStyle = 'rgba(200, 200, 200, 0.3)';
            minimapCtx.beginPath();
            minimapCtx.arc(center, center, center - 2, 0, Math.PI * 2);
            minimapCtx.fill();
            
            // Draw map border
            minimapCtx.strokeStyle = '#404040';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.arc(center, center, center - 2, 0, Math.PI * 2);
            minimapCtx.stroke();
            
            // Find player
            const player = gameState.players.find(p => p.id === playerId);
            if (!player) return;
            
            // Draw big polygons (pentagon=30, hexagon=40, octagon=50, decagon=60, dodecagon=70)
            if (gameState.polygons) {
                gameState.polygons.forEach(polygon => {
                    if (polygon.size >= 30) { // Only show pentagons and bigger
                        const x = center + polygon.x * minimapScale;
                        const y = center + polygon.y * minimapScale;
                        
                        // Different colors for different sizes
                        if (polygon.size >= 70) {
                            minimapCtx.fillStyle = '#FF6666'; // Dodecagon - red
                        } else if (polygon.size >= 60) {
                            minimapCtx.fillStyle = '#66CCFF'; // Decagon - cyan
                        } else if (polygon.size >= 50) {
                            minimapCtx.fillStyle = '#8B66FF'; // Octagon - purple
                        } else if (polygon.size >= 40) {
                            minimapCtx.fillStyle = '#FF6EC7'; // Hexagon - pink
                        } else {
                            minimapCtx.fillStyle = '#768CFF'; // Pentagon - blue
                        }
                        
                        minimapCtx.beginPath();
                        minimapCtx.arc(x, y, 3, 0, Math.PI * 2);
                        minimapCtx.fill();
                    }
                });
            }
            
            // Draw player arrow pointing at cursor
            const playerX = center + player.x * minimapScale;
            const playerY = center + player.y * minimapScale;
            
            minimapCtx.save();
            minimapCtx.translate(playerX, playerY);
            minimapCtx.rotate(player.rotation);
            
            // Draw arrow
            minimapCtx.fillStyle = '#00ff00'; // Green arrow
            minimapCtx.strokeStyle = '#004400';
            minimapCtx.lineWidth = 1;
            minimapCtx.beginPath();
            minimapCtx.moveTo(8, 0); // Point
            minimapCtx.lineTo(-4, -4); // Top back
            minimapCtx.lineTo(-2, 0); // Middle back
            minimapCtx.lineTo(-4, 4); // Bottom back
            minimapCtx.closePath();
            minimapCtx.fill();
            minimapCtx.stroke();
            
            minimapCtx.restore();
        }

        // Main render loop
        function render() {
            // Update mouse world position based on current camera (fixes stuck aim when camera moves)
            const world = screenToWorld(lastMouseScreenX, lastMouseScreenY);
            mouseWorldX = world.x;
            mouseWorldY = world.y;
            
            // Prevent text blur - use integer translation
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            
            // Clear with background color
            ctx.fillStyle = '#cdcdcd';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!gameState) {
                // Draw menu background (view of map center)
                camera.x = 0;
                camera.y = 0;
                camera.zoom = 0.5;

                ctx.restore();
                requestAnimationFrame(render);
                return;
            }

            // If player hasn't joined yet, show overview
            if (!playerId) {
                camera.x = 0;
                camera.y = 0;
                camera.zoom = 0.5;

                drawGrid();
                drawMapBorder();

                if (gameState) {
                    gameState.polygons.filter(p => isInViewport(p, p.size)).forEach(drawPolygon);
                    gameState.players.filter(p => isInViewport(p, p.size)).forEach(drawTank);
                }

                ctx.restore();
                requestAnimationFrame(render);
                return;
            }

            const player = gameState.players.find(p => p.id === playerId);
            if (!player) {
                ctx.restore();
                requestAnimationFrame(render);
                return;
            }

            // Smooth camera follow with acceleration
            targetCamera.x = player.x;
            targetCamera.y = player.y;

            const cameraSpeed = 0.15;
            camera.x += (targetCamera.x - camera.x) * cameraSpeed;
            camera.y += (targetCamera.y - camera.y) * cameraSpeed;

            // Draw everything (with frustum culling)
            drawGrid();
            drawMapBorder();

            // Draw polygons (only visible ones)
            gameState.polygons.filter(p => isInViewport(p, p.size)).forEach(drawPolygon);

            // Draw traps (only visible ones)
            gameState.traps.filter(t => isInViewport(t, t.size)).forEach(drawTrap);

            // Draw bullets (only visible ones)
            gameState.bullets.filter(b => isInViewport(b, b.size)).forEach(drawBullet);

            // Draw minions (only visible ones)
            gameState.minions.filter(m => isInViewport(m, m.size)).forEach(drawMinion);

            // Draw tanks (only visible ones)
            gameState.players.filter(p => isInViewport(p, p.size)).forEach(drawTank);

            // Draw minimap
            drawMinimap();

            ctx.restore();
            requestAnimationFrame(render);
        }

        // Start rendering
        render();

        // Initialize UI state
        updateControlHighlights();

        // ===== TANK EDITOR =====
        
        let editorState = {
            blocks: [],
            selectedBlock: null,
            selectedBlade: null,
            selectedBaseBlock: null,
            selectedType: null, // 'gun', 'blade', or 'baseBlock'
            rotation: 0,
            zoom: 1,
            dragging: false,
            lastMousePos: { x: 0, y: 0 },
            level: 1,
            fov: 1,
            baseMode: 'none', // none, simple, advanced
            baseSides: 4, // for simple mode
            baseBlocks: [], // for advanced mode: {id, shape, size, x, y, width, height, rotation, layer}
            blades: [] // list of blades: {id, shape (sides), size, x, y, rotation, layer}
        };

        const blockTypes = {
            normal: {
                name: 'Normal Gun',
                defaultProps: {
                    type: 'normal',
                    angle: 0,
                    blockRotation: 0, // NEW: Block itself's rotation
                    selfAngle: 0, // Current self-rotation angle (updated each frame)
                    selfAngleSpeed: 0, // Degrees per second to spin
                    offsetX: 0,
                    offsetY: 0,
                    damage: 1,
                    speed: 1,
                    reload: 1,
                    length: 1,
                    size: 1,
                    spread: 0,
                    recoil: 0, // Recoil (pushback when shooting)
                    bulletHealth: 0, // Override bullet health (0 = use penetration stat)
                    layer: 0,
                    color: '#999999'
                }
            },
            trap: {
                name: 'Trap Launcher',
                defaultProps: {
                    type: 'trap',
                    angle: 0,
                    blockRotation: 0, // NEW: Block itself's rotation
                    selfAngle: 0,
                    selfAngleSpeed: 0,
                    offsetX: 0,
                    offsetY: 0,
                    damage: 1,
                    speed: 0.8,
                    reload: 1.2,
                    maxTraps: 15,
                    trapSize: 1,
                    shootDistance: 8, // How far trap shoots out
                    friction: 0.92, // Friction/deceleration (lower = more friction)
                    recoil: 0, // Recoil (pushback when shooting)
                    layer: 0,
                    color: '#999999'
                }
            },
            minion: {
                name: 'Drone Spawner',
                defaultProps: {
                    type: 'minion',
                    angle: 0,
                    blockRotation: 0, // NEW: Block itself's rotation
                    selfAngle: 0,
                    selfAngleSpeed: 0,
                    count: 4,
                    damage: 1.5,
                    speed: 1.2,
                    minionSize: 1,
                    reload: 1,
                    recoil: 0, // Recoil (pushback when shooting)
                    layer: 0,
                    color: '#999999'
                }
            }
        };

        // Populate block list
        function populateBlockList() {
            const gunBlocksList = document.getElementById('gunBlocksList');
            gunBlocksList.innerHTML = '';
            
            for (const [type, config] of Object.entries(blockTypes)) {
                const btn = document.createElement('button');
                btn.textContent = '+ ' + config.name;
                btn.style.cssText = 'padding: 10px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;';
                btn.addEventListener('click', () => addBlock(type));
                gunBlocksList.appendChild(btn);
            }
        }
        
        function updateCurrentBlocksList() {
            const currentBlocksList = document.getElementById('currentBlocksList');
            currentBlocksList.innerHTML = '';
            
            if (editorState.blocks.length === 0) {
                currentBlocksList.innerHTML = '<div style="color: #888; font-size: 12px; font-style: italic;">No blocks added yet</div>';
                return;
            }
            
            editorState.blocks.forEach((block, index) => {
                const blockItem = document.createElement('div');
                blockItem.style.cssText = 'padding: 8px; background: ' + (editorState.selectedBlock?.id === block.id ? '#4a9eff' : '#1a1a1a') + '; border-radius: 4px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;';
                
                const blockName = document.createElement('span');
                blockName.textContent = `${index + 1}. ${blockTypes[block.type].name}`;
                blockName.style.cssText = 'color: white; font-size: 13px;';
                blockItem.appendChild(blockName);
                
                const delBtn = document.createElement('button');
                delBtn.textContent = 'Ã—';
                delBtn.style.cssText = 'padding: 2px 6px; background: #ff4444; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 14px; font-weight: bold;';
                delBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    editorState.blocks = editorState.blocks.filter(b => b.id !== block.id);
                    if (editorState.selectedBlock?.id === block.id) {
                        editorState.selectedBlock = null;
                    }
                    updateCurrentBlocksList();
                    updatePropertiesPanel();
                    renderEditorCanvas();
                });
                blockItem.appendChild(delBtn);
                
                blockItem.addEventListener('click', () => {
                    editorState.selectedBlock = block;
                    editorState.selectedBlade = null;
                    editorState.selectedBaseBlock = null;
                    editorState.selectedType = 'gun';
                    updateCurrentBlocksList();
                    updatePropertiesPanel();
                    renderEditorCanvas();
                });
                
                currentBlocksList.appendChild(blockItem);
            });
        }

        function addBlock(type) {
            const block = {
                id: Date.now(),
                type: type,
                props: { ...blockTypes[type].defaultProps }
            };
            editorState.blocks.push(block);
            editorState.selectedBlock = block;
            editorState.selectedBlade = null;
            editorState.selectedBaseBlock = null;
            editorState.selectedType = 'gun';
            updateCurrentBlocksList();
            updatePropertiesPanel();
            renderEditorCanvas();
        }

        function updateBladesList() {
            const bladesList = document.getElementById('bladesList');
            bladesList.innerHTML = '';
            
            if (editorState.blades.length === 0) {
                bladesList.innerHTML = '<div style="color: #888; font-size: 12px; font-style: italic;">No blades added</div>';
                return;
            }
            
            editorState.blades.forEach((blade, index) => {
                const bladeItem = document.createElement('div');
                const isSelected = editorState.selectedBlade?.id === blade.id;
                bladeItem.style.cssText = `padding: 6px; background: ${isSelected ? '#4a9eff' : '#1a1a1a'}; border-radius: 4px; display: flex; gap: 8px; align-items: center; cursor: pointer;`;
                
                // Preview canvas
                const preview = document.createElement('canvas');
                preview.width = 30;
                preview.height = 30;
                preview.style.cssText = 'flex-shrink: 0;';
                const ctx = preview.getContext('2d');
                ctx.fillStyle = '#00B2E1';
                ctx.beginPath();
                const sides = blade.shape;
                for (let i = 0; i <= sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                    const x = 15 + Math.cos(angle) * 12;
                    const y = 15 + Math.sin(angle) * 12;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                bladeItem.appendChild(preview);
                
                // Info
                const info = document.createElement('div');
                info.style.cssText = 'flex: 1; color: white; font-size: 12px;';
                info.textContent = `Blade ${index + 1} (${sides} sides)`;
                bladeItem.appendChild(info);
                
                // Delete button
                const delBtn = document.createElement('button');
                delBtn.textContent = 'Ã—';
                delBtn.style.cssText = 'padding: 2px 6px; background: #ff4444; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 14px; font-weight: bold;';
                delBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    editorState.blades.splice(index, 1);
                    if (editorState.selectedBlade?.id === blade.id) {
                        editorState.selectedBlade = null;
                        editorState.selectedType = null;
                    }
                    updateBladesList();
                    updatePropertiesPanel();
                    renderEditorCanvas();
                });
                bladeItem.appendChild(delBtn);
                
                // Click to select
                bladeItem.addEventListener('click', () => {
                    editorState.selectedBlade = blade;
                    editorState.selectedBlock = null;
                    editorState.selectedBaseBlock = null;
                    editorState.selectedType = 'blade';
                    updateBladesList();
                    updatePropertiesPanel();
                    renderEditorCanvas();
                });
                
                bladesList.appendChild(bladeItem);
            });
        }

        function updateBaseBlocksList() {
            const baseBlocksList = document.getElementById('baseBlocksList');
            baseBlocksList.innerHTML = '';
            
            if (editorState.baseBlocks.length === 0) {
                baseBlocksList.innerHTML = '<div style="color: #888; font-size: 12px; font-style: italic;">No base blocks added</div>';
                return;
            }
            
            editorState.baseBlocks.forEach((baseBlock, index) => {
                const blockItem = document.createElement('div');
                const isSelected = editorState.selectedBaseBlock?.id === baseBlock.id;
                blockItem.style.cssText = `padding: 6px; background: ${isSelected ? '#4a9eff' : '#1a1a1a'}; border-radius: 4px; display: flex; gap: 8px; align-items: center; cursor: pointer;`;
                
                // Info
                const info = document.createElement('div');
                info.style.cssText = 'flex: 1; color: white; font-size: 12px;';
                info.textContent = `Block ${index + 1} (${baseBlock.shape === 0 ? 'Circle' : baseBlock.shape + ' sides'})`;
                blockItem.appendChild(info);
                
                // Delete button
                const delBtn = document.createElement('button');
                delBtn.textContent = 'Ã—';
                delBtn.style.cssText = 'padding: 2px 6px; background: #ff4444; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 14px; font-weight: bold;';
                delBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    editorState.baseBlocks.splice(index, 1);
                    if (editorState.selectedBaseBlock?.id === baseBlock.id) {
                        editorState.selectedBaseBlock = null;
                        editorState.selectedType = null;
                    }
                    updateBaseBlocksList();
                    updatePropertiesPanel();
                    renderEditorCanvas();
                });
                blockItem.appendChild(delBtn);
                
                // Click to select
                blockItem.addEventListener('click', () => {
                    editorState.selectedBaseBlock = baseBlock;
                    editorState.selectedBlock = null;
                    editorState.selectedBlade = null;
                    editorState.selectedType = 'baseBlock';
                    updateBaseBlocksList();
                    updatePropertiesPanel();
                    renderEditorCanvas();
                });
                
                baseBlocksList.appendChild(blockItem);
            });
        }

        function updatePropertiesPanel() {
            const panel = document.getElementById('editorPropertiesContent');
            
            // Handle guns
            if (editorState.selectedType === 'gun' && editorState.selectedBlock) {
                const block = editorState.selectedBlock;
                
                panel.innerHTML = `
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #4a9eff;">${blockTypes[block.type].name}</strong>
                        <button id="duplicateBlockBtn" style="float: right; padding: 5px 10px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 5px;">Duplicate</button>
                        <button id="deleteBlockBtn" style="float: right; padding: 5px 10px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;">Delete</button>
                    </div>
                `;

                for (const [key, value] of Object.entries(block.props)) {
                    // Skip the 'type' and 'selfAngle' properties - type is determined by block type, selfAngle is internal state
                    if (key === 'type' || key === 'selfAngle') continue;
                    
                    const label = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    const propDiv = document.createElement('div');
                    propDiv.style.marginBottom = '12px';

                    const labelEl = document.createElement('label');
                    labelEl.textContent = label + ':';
                    labelEl.style.cssText = 'display: block; margin-bottom: 5px; color: #aaa; font-size: 13px;';
                    propDiv.appendChild(labelEl);

                    let input;
                    if (key === 'color') {
                        input = document.createElement('input');
                        input.type = 'color';
                        input.value = value;
                        input.style.cssText = 'width: 100%; height: 35px; border: none; border-radius: 4px; cursor: pointer;';
                    } else if (typeof value === 'boolean') {
                        input = document.createElement('input');
                        input.type = 'checkbox';
                        input.checked = value;
                        input.style.cssText = 'width: 20px; height: 20px; cursor: pointer;';
                    } else {
                        input = document.createElement('input');
                        input.type = 'number';
                        input.value = value;
                        input.step = key.includes('reload') || key.includes('damage') || key.includes('speed') || key.includes('recoil') || key.includes('penetration') || key.includes('health') || key.includes('Speed') || key.includes('bulletHealth') || key.includes('friction') || key.includes('shootDistance') ? '0.1' : '1';
                        input.style.cssText = 'width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px;';
                    }

                    input.addEventListener('input', (e) => {
                        if (input.type === 'checkbox') {
                            block.props[key] = e.target.checked;
                        } else if (input.type === 'color') {
                            block.props[key] = e.target.value;
                        } else {
                            block.props[key] = parseFloat(e.target.value) || 0;
                        }
                        renderEditorCanvas();
                    });

                    propDiv.appendChild(input);
                    panel.appendChild(propDiv);
                }

                document.getElementById('duplicateBlockBtn').addEventListener('click', () => {
                    const duplicate = {
                        id: Date.now(),
                        type: block.type,
                        props: { ...block.props }
                    };
                    editorState.blocks.push(duplicate);
                    editorState.selectedBlock = duplicate;
                    updateCurrentBlocksList();
                    updatePropertiesPanel();
                    renderEditorCanvas();
                });

                document.getElementById('deleteBlockBtn').addEventListener('click', () => {
                    editorState.blocks = editorState.blocks.filter(b => b.id !== block.id);
                    editorState.selectedBlock = null;
                    editorState.selectedType = null;
                    updateCurrentBlocksList();
                    updatePropertiesPanel();
                    renderEditorCanvas();
                });
            }
            // Handle blades
            else if (editorState.selectedType === 'blade' && editorState.selectedBlade) {
                const blade = editorState.selectedBlade;
                
                panel.innerHTML = `
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #4a9eff;">Blade</strong>
                        <button id="duplicateBladeBtn" style="float: right; padding: 5px 10px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 5px;">Duplicate</button>
                        <button id="deleteBladeBtn" style="float: right; padding: 5px 10px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;">Delete</button>
                    </div>
                `;

                const props = {
                    'Shape (sides)': { key: 'shape', type: 'number', min: 3, max: 16, step: 1, value: blade.shape },
                    'Size': { key: 'size', type: 'number', min: 0.5, max: 3, step: 0.1, value: blade.size },
                    'X Position': { key: 'x', type: 'number', min: -50, max: 50, step: 1, value: blade.x },
                    'Y Position': { key: 'y', type: 'number', min: -50, max: 50, step: 1, value: blade.y },
                    'Rotation': { key: 'rotation', type: 'number', min: 0, max: 360, step: 1, value: blade.rotation },
                    'Layer': { key: 'layer', type: 'number', min: -10, max: 10, step: 1, value: blade.layer },
                    'Color': { key: 'color', type: 'color', value: blade.color || '#999999' }
                };

                for (const [label, prop] of Object.entries(props)) {
                    const propDiv = document.createElement('div');
                    propDiv.style.marginBottom = '12px';

                    const labelEl = document.createElement('label');
                    labelEl.textContent = label + ':';
                    labelEl.style.cssText = 'display: block; margin-bottom: 5px; color: #aaa; font-size: 13px;';
                    propDiv.appendChild(labelEl);

                    const input = document.createElement('input');
                    if (prop.type === 'color') {
                        input.type = 'color';
                        input.value = prop.value;
                        input.style.cssText = 'width: 100%; height: 35px; border: none; border-radius: 4px; cursor: pointer;';
                        input.addEventListener('input', (e) => {
                            blade[prop.key] = e.target.value;
                            updateBladesList();
                            renderEditorCanvas();
                        });
                    } else {
                        input.type = 'number';
                        input.value = prop.value;
                        input.min = prop.min;
                        input.max = prop.max;
                        input.step = prop.step;
                        input.style.cssText = 'width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px;';
                        input.addEventListener('input', (e) => {
                            blade[prop.key] = parseFloat(e.target.value) || 0;
                            updateBladesList();
                            renderEditorCanvas();
                        });
                    }

                    propDiv.appendChild(input);
                    panel.appendChild(propDiv);
                }

                document.getElementById('duplicateBladeBtn').addEventListener('click', () => {
                    const duplicate = {
                        id: Date.now(),
                        shape: blade.shape,
                        size: blade.size,
                        x: blade.x,
                        y: blade.y,
                        rotation: blade.rotation,
                        layer: blade.layer,
                        color: blade.color
                    };
                    editorState.blades.push(duplicate);
                    editorState.selectedBlade = duplicate;
                    updateBladesList();
                    updatePropertiesPanel();
                    renderEditorCanvas();
                });

                document.getElementById('deleteBladeBtn').addEventListener('click', () => {
                    editorState.blades = editorState.blades.filter(b => b.id !== blade.id);
                    editorState.selectedBlade = null;
                    editorState.selectedType = null;
                    updateBladesList();
                    updatePropertiesPanel();
                    renderEditorCanvas();
                });
            }
            // Handle base blocks
            else if (editorState.selectedType === 'baseBlock' && editorState.selectedBaseBlock) {
                const baseBlock = editorState.selectedBaseBlock;
                
                panel.innerHTML = `
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #4a9eff;">Base Block</strong>
                        <button id="duplicateBaseBlockBtn" style="float: right; padding: 5px 10px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 5px;">Duplicate</button>
                        <button id="deleteBaseBlockBtn" style="float: right; padding: 5px 10px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;">Delete</button>
                    </div>
                `;

                const props = {
                    'Shape (0=circle)': { key: 'shape', type: 'number', min: 0, max: 16, step: 1, value: baseBlock.shape },
                    'Size': { key: 'size', type: 'number', min: 10, max: 50, step: 1, value: baseBlock.size },
                    'X Position': { key: 'x', type: 'number', min: -50, max: 50, step: 1, value: baseBlock.x },
                    'Y Position': { key: 'y', type: 'number', min: -50, max: 50, step: 1, value: baseBlock.y },
                    'Width': { key: 'width', type: 'number', min: 10, max: 50, step: 1, value: baseBlock.width },
                    'Height': { key: 'height', type: 'number', min: 10, max: 50, step: 1, value: baseBlock.height },
                    'Rotation': { key: 'rotation', type: 'number', min: 0, max: 360, step: 1, value: baseBlock.rotation },
                    'Layer': { key: 'layer', type: 'number', min: -10, max: 10, step: 1, value: baseBlock.layer },
                    'Color': { key: 'color', type: 'color', value: baseBlock.color || '#00b2e1' }
                };

                for (const [label, prop] of Object.entries(props)) {
                    const propDiv = document.createElement('div');
                    propDiv.style.marginBottom = '12px';

                    const labelEl = document.createElement('label');
                    labelEl.textContent = label + ':';
                    labelEl.style.cssText = 'display: block; margin-bottom: 5px; color: #aaa; font-size: 13px;';
                    propDiv.appendChild(labelEl);

                    const input = document.createElement('input');
                    if (prop.type === 'color') {
                        input.type = 'color';
                        input.value = prop.value;
                        input.style.cssText = 'width: 100%; height: 35px; border: none; border-radius: 4px; cursor: pointer;';
                        input.addEventListener('input', (e) => {
                            baseBlock[prop.key] = e.target.value;
                            updateBaseBlocksList();
                            renderEditorCanvas();
                        });
                    } else {
                        input.type = 'number';
                        input.value = prop.value;
                        input.min = prop.min;
                        input.max = prop.max;
                        input.step = prop.step;
                        input.style.cssText = 'width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px;';
                        input.addEventListener('input', (e) => {
                            baseBlock[prop.key] = parseFloat(e.target.value) || 0;
                            updateBaseBlocksList();
                            renderEditorCanvas();
                        });
                    }
                    input.step = prop.step;
                    input.style.cssText = 'width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px;';

                    input.addEventListener('input', (e) => {
                        baseBlock[prop.key] = parseFloat(e.target.value) || 0;
                        updateBaseBlocksList();
                        renderEditorCanvas();
                    });

                    propDiv.appendChild(input);
                    panel.appendChild(propDiv);
                }

                document.getElementById('duplicateBaseBlockBtn').addEventListener('click', () => {
                    const duplicate = {
                        id: Date.now(),
                        shape: baseBlock.shape,
                        size: baseBlock.size,
                        x: baseBlock.x,
                        y: baseBlock.y,
                        width: baseBlock.width,
                        height: baseBlock.height,
                        rotation: baseBlock.rotation,
                        layer: baseBlock.layer,
                        color: baseBlock.color
                    };
                    editorState.baseBlocks.push(duplicate);
                    editorState.selectedBaseBlock = duplicate;
                    updateBaseBlocksList();
                    updatePropertiesPanel();
                    renderEditorCanvas();
                });

                document.getElementById('deleteBaseBlockBtn').addEventListener('click', () => {
                    editorState.baseBlocks = editorState.baseBlocks.filter(b => b.id !== baseBlock.id);
                    editorState.selectedBaseBlock = null;
                    editorState.selectedType = null;
                    updateBaseBlocksList();
                    updatePropertiesPanel();
                    renderEditorCanvas();
                });
            }
            // Nothing selected
            else {
                panel.innerHTML = '<div style="color: #aaa; font-size: 14px;">Select a gun, blade, or base block to edit</div>';
            }
        }

        // Calculate final baked position and rotation for a gun based on editor transform sequence
        // This matches EXACTLY how the editor renders guns
        function calculateBakedGunTransform(gunProps) {
            const angle = (gunProps.angle || 0) * Math.PI / 180;
            const blockRotation = (gunProps.blockRotation || 0) * Math.PI / 180;
            const selfAngle = (gunProps.selfAngle || 0) * Math.PI / 180;
            const offsetX = gunProps.offsetX || 0;
            const offsetY = gunProps.offsetY || 0;
            
            // Get radius and face angle at this position
            const { radius: baseRadius, faceAngle } = getEditorBaseRadiusAndFace(angle);
            
            // Editor transform sequence (matching renderEditorCanvas exactly):
            // 1. ctx.rotate(angle) - rotates coordinate system by angle
            // 2. ctx.translate(baseRadius, 0) - moves baseRadius units along rotated X-axis
            // 3. ctx.rotate(faceAngle - angle) - rotates by additional (faceAngle - angle)
            // 4. ctx.rotate(blockRotation + selfAngle) - rotates by blockRotation + selfAngle
            // 5. ctx.translate(offsetX, offsetY) - moves along final rotated axes
            
            // Final rotation is cumulative: angle + (faceAngle - angle) + blockRotation + selfAngle
            const finalRotation = faceAngle + blockRotation + selfAngle;
            
            // Calculate final position using matrix transformations
            // After step 1 (rotate angle): position is still (0, 0)
            // After step 2 (translate baseRadius, 0 in rotated space):
            //   x = baseRadius * cos(angle), y = baseRadius * sin(angle)
            let x = Math.cos(angle) * baseRadius;
            let y = Math.sin(angle) * baseRadius;
            
            // After steps 3-4 (rotations don't change position, only orientation)
            // Position is still (x, y)
            
            // After step 5 (translate offsetX, offsetY in the rotated space):
            // The current rotation is finalRotation, so:
            //   dx = offsetX * cos(finalRotation) - offsetY * sin(finalRotation)
            //   dy = offsetX * sin(finalRotation) + offsetY * cos(finalRotation)
            x += Math.cos(finalRotation) * offsetX - Math.sin(finalRotation) * offsetY;
            y += Math.sin(finalRotation) * offsetX + Math.cos(finalRotation) * offsetY;
            
            return {
                x: x,
                y: y,
                rotation: finalRotation
            };
        }

        // Calculate base radius and face angle at angle for editor preview
        // Returns { radius, faceAngle } where faceAngle is perpendicular to the face
        function getEditorBaseRadiusAndFace(angle) {
            const tankSize = 20; // Match in-game base tank size
            
            if (editorState.baseMode === 'none') {
                // Circle - constant radius, face perpendicular to radius
                return { radius: tankSize, faceAngle: angle };
            } else if (editorState.baseMode === 'simple') {
                // Regular polygon centered at origin
                const sides = editorState.baseSides;
                const anglePerSide = (Math.PI * 2) / sides;
                
                // Find which side this angle points to
                const normalizedAngle = angle + Math.PI / 2; // Offset for polygon orientation
                const sideIndex = Math.floor((normalizedAngle + anglePerSide / 2) / anglePerSide);
                const sideAngle = sideIndex * anglePerSide;
                
                // Calculate distance to that side
                const angleToEdge = angle - sideAngle + Math.PI / 2;
                const cosAngle = Math.cos(angleToEdge);
                
                const radius = Math.abs(cosAngle) > 0.001 ? tankSize / cosAngle : tankSize;
                
                // Face angle is perpendicular to the side (same for all points on a flat face)
                const faceAngle = sideAngle - Math.PI / 2;
                
                return { radius, faceAngle };
            } else if (editorState.baseMode === 'advanced' && editorState.baseBlocks.length > 0) {
                // Advanced mode with custom positioned/rotated base blocks
                // Cast a ray from origin at 'angle' and find furthest intersection
                let maxRadius = 0;
                let maxFaceAngle = angle; // Default to pointing outward
                
                // For each base block, calculate distance to edge along the ray
                for (const baseBlock of editorState.baseBlocks) {
                    const bx = baseBlock.x || 0;
                    const by = baseBlock.y || 0;
                    const bRot = (baseBlock.rotation || 0) * Math.PI / 180;
                    const shape = baseBlock.shape || 0;
                    const size = baseBlock.size || tankSize;
                    const width = baseBlock.width || 0;
                    const height = baseBlock.height || 0;
                    
                    if (shape === 0) {
                        // Circle - distance from origin to furthest point of circle
                        const centerDist = Math.sqrt(bx * bx + by * by);
                        const radius = size + width;
                        const angleToCenter = Math.atan2(by, bx);
                        const angleDiff = angle - angleToCenter;
                        
                        // Distance along ray to circle edge
                        const a = centerDist * centerDist * Math.sin(angleDiff) * Math.sin(angleDiff);
                        const discriminant = radius * radius - a;
                        
                        if (discriminant >= 0) {
                            const distToEdge = centerDist * Math.cos(angleDiff) + Math.sqrt(discriminant);
                            if (!isNaN(distToEdge) && distToEdge > maxRadius) {
                                maxRadius = distToEdge;
                                // For circle, face is perpendicular to radius at that point
                                maxFaceAngle = angle;
                            }
                        }
                    } else if (shape === 4 && (width || height)) {
                        // Rectangle - check intersection with rotated rectangle edges
                        const totalWidth = size + width;
                        const totalHeight = size + height;
                        
                        // Ray direction in world space
                        const rayDx = Math.cos(angle);
                        const rayDy = Math.sin(angle);
                        
                        // Transform ray to rectangle's local space
                        const localRayDx = rayDx * Math.cos(-bRot) - rayDy * Math.sin(-bRot);
                        const localRayDy = rayDx * Math.sin(-bRot) + rayDy * Math.cos(-bRot);
                        
                        // Ray starts from origin, but rectangle is at (bx, by)
                        // Transform origin to local space
                        const localOriginX = -bx * Math.cos(-bRot) + by * Math.sin(-bRot);
                        const localOriginY = -bx * Math.sin(-bRot) - by * Math.cos(-bRot);
                        
                        // Check intersection with each of the 4 edges
                        const halfW = totalWidth / 2;
                        const halfH = totalHeight / 2;
                        
                        let bestT = -1;
                        let bestFace = 0; // 0=right, 1=top, 2=left, 3=bottom
                        
                        // Right edge (x = halfW)
                        if (Math.abs(localRayDx) > 0.001) {
                            const t = (halfW - localOriginX) / localRayDx;
                            const y = localOriginY + t * localRayDy;
                            if (t > 0 && Math.abs(y) <= halfH && (bestT < 0 || t > bestT)) {
                                bestT = t;
                                bestFace = 0;
                            }
                        }
                        
                        // Left edge (x = -halfW)
                        if (Math.abs(localRayDx) > 0.001) {
                            const t = (-halfW - localOriginX) / localRayDx;
                            const y = localOriginY + t * localRayDy;
                            if (t > 0 && Math.abs(y) <= halfH && (bestT < 0 || t > bestT)) {
                                bestT = t;
                                bestFace = 2;
                            }
                        }
                        
                        // Top edge (y = halfH)
                        if (Math.abs(localRayDy) > 0.001) {
                            const t = (halfH - localOriginY) / localRayDy;
                            const x = localOriginX + t * localRayDx;
                            if (t > 0 && Math.abs(x) <= halfW && (bestT < 0 || t > bestT)) {
                                bestT = t;
                                bestFace = 1;
                            }
                        }
                        
                        // Bottom edge (y = -halfH)
                        if (Math.abs(localRayDy) > 0.001) {
                            const t = (-halfH - localOriginY) / localRayDy;
                            const x = localOriginX + t * localRayDx;
                            if (t > 0 && Math.abs(x) <= halfW && (bestT < 0 || t > bestT)) {
                                bestT = t;
                                bestFace = 3;
                            }
                        }
                        
                        if (bestT > 0 && bestT > maxRadius) {
                            maxRadius = bestT;
                            // Face angle in local space: 0=right (0Â°), 1=top (90Â°), 2=left (180Â°), 3=bottom (270Â°)
                            const localFaceAngle = bestFace * Math.PI / 2;
                            // Transform face angle back to world space
                            maxFaceAngle = localFaceAngle + bRot;
                        }
                    } else if (shape > 0) {
                        // Regular polygon
                        const sides = shape;
                        const anglePerSide = (Math.PI * 2) / sides;
                        
                        // Transform angle to baseBlock's local space
                        const localAngle = angle - bRot;
                        
                        // Find which side this angle points to
                        const normalizedAngle = localAngle + Math.PI / 2;
                        const sideIndex = Math.floor((normalizedAngle + anglePerSide / 2) / anglePerSide);
                        const sideAngle = sideIndex * anglePerSide;
                        
                        // Calculate distance to that side in local space
                        const angleToEdge = localAngle - sideAngle + Math.PI / 2;
                        const cosAngle = Math.cos(angleToEdge);
                        
                        let localRadius;
                        if (Math.abs(cosAngle) > 0.001) {
                            localRadius = (size + width) / cosAngle;
                        } else {
                            localRadius = size + width;
                        }
                        
                        // Transform from block center to world origin
                        const centerDist = Math.sqrt(bx * bx + by * by);
                        const angleToCenter = Math.atan2(by, bx);
                        const angleDiff = angle - angleToCenter;
                        
                        // Project the local radius along the ray
                        const distToEdge = centerDist * Math.cos(angleDiff) + localRadius;
                        
                        if (distToEdge > maxRadius) {
                            maxRadius = distToEdge;
                            // Face angle in local space, transformed to world space
                            const localFaceAngle = sideAngle - Math.PI / 2;
                            maxFaceAngle = localFaceAngle + bRot;
                        }
                    }
                }
                
                return maxRadius > 0 ? { radius: maxRadius, faceAngle: maxFaceAngle } : { radius: tankSize, faceAngle: angle };
            }
            
            // Default to circle
            return { radius: tankSize, faceAngle: angle };
        }

        // Legacy function for backward compatibility
        function getEditorBaseRadius(angle) {
            return getEditorBaseRadiusAndFace(angle).radius;
        }

        function renderEditorCanvas() {
            const canvas = document.getElementById('editorCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 800;
            canvas.height = 600;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const tankSize = 20; // Match in-game base tank size

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(editorState.zoom, editorState.zoom);
            ctx.rotate(editorState.rotation);

            // Collect all drawable elements with layers
            const drawables = [];
            
            // Add base (layer 0 by default)
            drawables.push({ type: 'base', layer: 0 });
            
            // Add base blocks
            editorState.baseBlocks.forEach(baseBlock => {
                drawables.push({ type: 'baseBlock', layer: baseBlock.layer || 0, data: baseBlock });
            });
            
            // Add blades
            editorState.blades.forEach(blade => {
                drawables.push({ type: 'blade', layer: blade.layer || 0, data: blade });
            });
            
            // Add guns
            editorState.blocks.forEach(block => {
                drawables.push({ type: 'gun', layer: block.props.layer || 0, data: block });
            });
            
            // Sort by layer (lower = behind, higher = in front)
            drawables.sort((a, b) => a.layer - b.layer);
            
            // Render all elements in layer order
            drawables.forEach(drawable => {
                if (drawable.type === 'base') {
                    // Draw tank body based on base mode
                    const baseColor = '#00b2e1';
                    ctx.fillStyle = baseColor;
                    ctx.strokeStyle = darkenColor(baseColor, 0.3);
                    ctx.lineWidth = 3;
                    
                    if (editorState.baseMode === 'none') {
                        // Circle base
                        ctx.beginPath();
                        ctx.arc(0, 0, tankSize, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else if (editorState.baseMode === 'simple') {
                        // Polygon base
                        const sides = editorState.baseSides;
                        ctx.beginPath();
                        for (let i = 0; i < sides; i++) {
                            const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                            const x = Math.cos(angle) * tankSize;
                            const y = Math.sin(angle) * tankSize;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    } else if (editorState.baseMode === 'advanced') {
                        // Advanced mode - base blocks render separately, no default base
                        if (editorState.baseBlocks.length === 0) {
                            // Only show placeholder circle if no blocks added yet
                            ctx.beginPath();
                            ctx.arc(0, 0, tankSize, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                            ctx.strokeStyle = '#333';
                            ctx.lineWidth = 3;
                            ctx.stroke();
                        }
                    }
                } else if (drawable.type === 'baseBlock') {
                    const baseBlock = drawable.data;
                    ctx.save();
                    ctx.translate(baseBlock.x, baseBlock.y);
                    ctx.rotate(baseBlock.rotation * Math.PI / 180);
                    
                    ctx.fillStyle = baseBlock.color || '#00b2e1';
                    if (baseBlock.shape === 0) {
                        // Circle
                        ctx.beginPath();
                        ctx.arc(0, 0, baseBlock.size + (baseBlock.width || 0), 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = darkenColor(baseBlock.color || '#00b2e1', 0.3);
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    } else if (baseBlock.shape === 4 && (baseBlock.width || baseBlock.height)) {
                        // Rectangle (when shape is 4 and width/height are set)
                        const totalWidth = baseBlock.size + (baseBlock.width || 0);
                        const totalHeight = baseBlock.size + (baseBlock.height || 0);
                        ctx.beginPath();
                        ctx.rect(-totalWidth/2, -totalHeight/2, totalWidth, totalHeight);
                        ctx.fill();
                        ctx.strokeStyle = darkenColor(baseBlock.color || '#00b2e1', 0.3);
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    } else {
                        // Polygon
                        ctx.beginPath();
                        const sides = baseBlock.shape;
                        const radiusX = baseBlock.size + (baseBlock.width || 0);
                        const radiusY = baseBlock.size + (baseBlock.height || 0);
                        for (let i = 0; i < sides; i++) {
                            const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                            const x = Math.cos(angle) * radiusX;
                            const y = Math.sin(angle) * radiusY;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = darkenColor(baseBlock.color || '#00b2e1', 0.3);
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                    ctx.restore();
                } else if (drawable.type === 'blade') {
                    const blade = drawable.data;
                    ctx.save();
                    ctx.translate(blade.x, blade.y);
                    ctx.rotate(blade.rotation * Math.PI / 180);
                    
                    const sides = blade.shape;
                    const bladeSize = blade.size * 20;
                    
                    ctx.fillStyle = blade.color || '#999999';
                    ctx.beginPath();
                    for (let j = 0; j < sides; j++) {
                        const angle = (j / sides) * Math.PI * 2 - Math.PI / 2;
                        const x = Math.cos(angle) * bladeSize;
                        const y = Math.sin(angle) * bladeSize;
                        if (j === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.strokeStyle = darkenColor(blade.color || '#999999', 0.3);
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    ctx.restore();
                } else if (drawable.type === 'gun') {
                    const block = drawable.data;
                    const editorSizeMultiplier = 1; // Editor uses 1:1 scale
                    
                    ctx.save();
                    
                    const angle = (block.props.angle || 0) * Math.PI / 180;
                    const blockRotation = (block.props.blockRotation || 0) * Math.PI / 180;
                    const selfAngle = (block.props.selfAngle || 0) * Math.PI / 180;
                    
                    // Get radius and face angle at this position
                    const { radius: baseRadius, faceAngle } = getEditorBaseRadiusAndFace(angle);
                    
                    // Position gun on perimeter at 'angle'
                    ctx.rotate(angle);
                    ctx.translate(baseRadius, 0);
                    
                    // Rotate to align with face (perpendicular to surface)
                    ctx.rotate(faceAngle - angle);
                    
                    // Apply additional rotations
                    ctx.rotate(blockRotation + selfAngle);
                    ctx.translate(block.props.offsetX || 0, block.props.offsetY || 0);
                
                    const gunColor = block.props.color || '#999';
                    ctx.fillStyle = gunColor;
                    ctx.strokeStyle = editorState.selectedBlock?.id === block.id ? '#ffff00' : darkenColor(gunColor, 0.3);
                    ctx.lineWidth = editorState.selectedBlock?.id === block.id ? 3 : 2;
                    
                    if (block.type === 'normal') {
                        const gunLength = (block.props.length || 1) * 20;
                        const gunWidth = (block.props.size || 1) * 20;
                        
                        ctx.fillRect(-5, -gunWidth / 2, gunLength, gunWidth);
                        ctx.strokeRect(-5, -gunWidth / 2, gunLength, gunWidth);
                    } else if (block.type === 'trap') {
                        const baseLength = 20;
                        const baseHeight = 20;
                        const flatRectWidth = 30;
                        const flatRectHeight = 8;
                        
                        // Base rectangle (horizontal part of rotated T)
                        ctx.fillRect(-5, -baseHeight / 2, baseLength, baseHeight);
                        ctx.strokeRect(-5, -baseHeight / 2, baseLength, baseHeight);
                        
                        // Front flat rectangle (vertical part of rotated T)
                        ctx.fillRect(-5 + baseLength, -flatRectWidth / 2, flatRectHeight, flatRectWidth);
                        ctx.strokeRect(-5 + baseLength, -flatRectWidth / 2, flatRectHeight, flatRectWidth);
                    } else if (block.type === 'minion') {
                        const length = 25;
                        const baseWidth = 8;
                        const tipWidth = 18;
                        
                        ctx.beginPath();
                        ctx.moveTo(-5, -baseWidth / 2);
                        ctx.lineTo(-5 + length, -tipWidth / 2);
                        ctx.lineTo(-5 + length, tipWidth / 2);
                        ctx.lineTo(-5, baseWidth / 2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            });

            ctx.restore();
            
            // Display zoom and rotation info in top-left corner
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(10, 10, 180, 50);
            
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(`Zoom: ${(editorState.zoom * 100).toFixed(0)}%`, 20, 20);
            ctx.fillText(`Rotation: ${((editorState.rotation * 180 / Math.PI) % 360).toFixed(0)}Â°`, 20, 40);
            ctx.restore();
        }

        // Editor canvas mouse interactions
        const editorCanvas = document.getElementById('editorCanvas');
        
        editorCanvas.addEventListener('mousedown', (e) => {
            const rect = editorCanvas.getBoundingClientRect();
            const startX = e.clientX;
            const startY = e.clientY;
            
            editorState.mouseDownPos = { x: startX, y: startY };
            editorState.isDragging = false;
            editorState.dragging = true;
            editorState.lastMousePos = { x: startX, y: startY };
        });

        editorCanvas.addEventListener('mousemove', (e) => {
            if (editorState.dragging) {
                const dx = e.clientX - editorState.lastMousePos.x;
                const dy = e.clientY - editorState.lastMousePos.y;
                
                // Check if moved enough to be considered a drag
                if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
                    editorState.isDragging = true;
                    editorCanvas.style.cursor = 'grabbing';
                }
                
                // Horizontal drag rotates, vertical drag zooms
                editorState.rotation += dx * 0.01;
                editorState.zoom = Math.max(0.5, Math.min(3, editorState.zoom + dy * 0.005));
                
                editorState.lastMousePos = { x: e.clientX, y: e.clientY };
                renderEditorCanvas();
            }
        });

        editorCanvas.addEventListener('mouseup', (e) => {
            if (!editorState.isDragging) {
                // It's a click, not a drag
                const rect = editorCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const centerX = editorCanvas.width / 2;
                const centerY = editorCanvas.height / 2;
                
                // Transform mouse coordinates to account for zoom and rotation
                const relX = (mouseX - centerX) / editorState.zoom;
                const relY = (mouseY - centerY) / editorState.zoom;
                
                // Rotate back by negative rotation to get world coordinates
                const cos = Math.cos(-editorState.rotation);
                const sin = Math.sin(-editorState.rotation);
                const worldX = relX * cos - relY * sin;
                const worldY = relX * sin + relY * cos;
                
                let clickedItem = null;
                let clickedType = null;
                
                // Check guns (in reverse order to prioritize top-most)
                for (let i = editorState.blocks.length - 1; i >= 0; i--) {
                    const block = editorState.blocks[i];
                    const angle = (block.props.angle || 0) * Math.PI / 180;
                    const blockRotation = (block.props.blockRotation || 0) * Math.PI / 180;
                    const selfAngle = (block.props.selfAngle || 0) * Math.PI / 180;
                    
                    // Calculate gun position on perimeter
                    const baseRadius = getEditorBaseRadius(angle);
                    const gunX = Math.cos(angle) * baseRadius + (block.props.offsetX || 0);
                    const gunY = Math.sin(angle) * baseRadius + (block.props.offsetY || 0);
                    
                    const blockDist = Math.sqrt(
                        (worldX - gunX) ** 2 + 
                        (worldY - gunY) ** 2
                    );
                    
                    // Simple hit detection - 40 pixel radius
                    if (blockDist < 40) {
                        clickedItem = block;
                        clickedType = 'gun';
                        break;
                    }
                }
                
                // Check blades if no gun was clicked
                if (!clickedItem) {
                    for (let i = editorState.blades.length - 1; i >= 0; i--) {
                        const blade = editorState.blades[i];
                        const bladeDist = Math.sqrt(
                            (worldX - blade.x) ** 2 + 
                            (worldY - blade.y) ** 2
                        );
                        
                        // Hit detection based on blade size
                        if (bladeDist < blade.size * 20) {
                            clickedItem = blade;
                            clickedType = 'blade';
                            break;
                        }
                    }
                }
                
                // Check base blocks if no gun or blade was clicked
                if (!clickedItem) {
                    for (let i = editorState.baseBlocks.length - 1; i >= 0; i--) {
                        const baseBlock = editorState.baseBlocks[i];
                        const baseBlockDist = Math.sqrt(worldX ** 2 + worldY ** 2);
                        
                        // Hit detection based on base block size
                        const totalSize = baseBlock.size + Math.max(baseBlock.width || 0, baseBlock.height || 0);
                        if (baseBlockDist < totalSize) {
                            clickedItem = baseBlock;
                            clickedType = 'baseBlock';
                            break;
                        }
                    }
                }
                
                if (clickedItem) {
                    if (clickedType === 'gun') {
                        editorState.selectedBlock = clickedItem;
                        editorState.selectedBlade = null;
                        editorState.selectedBaseBlock = null;
                    } else if (clickedType === 'blade') {
                        editorState.selectedBlade = clickedItem;
                        editorState.selectedBlock = null;
                        editorState.selectedBaseBlock = null;
                    } else if (clickedType === 'baseBlock') {
                        editorState.selectedBaseBlock = clickedItem;
                        editorState.selectedBlock = null;
                        editorState.selectedBlade = null;
                    }
                } else {
                    // Clicked on empty space - deselect all
                    editorState.selectedBlock = null;
                    editorState.selectedBlade = null;
                    editorState.selectedBaseBlock = null;
                }
                
                updateCurrentBlocksList();
                updatePropertiesPanel();
                renderEditorCanvas();
            }
            
            editorState.dragging = false;
            editorState.isDragging = false;
            editorCanvas.style.cursor = 'grab';
        });

        editorCanvas.addEventListener('mouseleave', () => {
            editorState.dragging = false;
            editorState.isDragging = false;
            editorCanvas.style.cursor = 'grab';
        });

        // Open/Close Tank Editor
        document.getElementById('openTankEditorBtn').addEventListener('click', () => {
            // If in game, leave it before opening editor (despawn)
            if (playerId) {
                console.log('[EDITOR] Leaving game before opening editor');
                socket.emit('playerLeaveGame');
                playerId = null;
                document.getElementById('hud').classList.remove('visible');
            }
            
            // Open editor, hide menus (stay despawned)
            document.getElementById('tankEditor').style.display = 'block';
            document.getElementById('startMenu').classList.add('hidden');
            document.getElementById('cheatPanel').style.display = 'none';
            cheatPanelActive = false;
            
            // Initialize editor UI
            populateBlockList();
            updateCurrentBlocksList();
            updateBladesList();
            updateBaseBlocksList();
            updatePropertiesPanel();
            renderEditorCanvas();
            
            console.log('[EDITOR] Editor opened (despawned)');
        });

        // Base Mode Handler
        document.getElementById('baseModeSelect').addEventListener('change', (e) => {
            const newMode = e.target.value;
            
            // Warn when leaving advanced mode with custom base blocks
            if (editorState.baseMode === 'advanced' && newMode !== 'advanced' && editorState.baseBlocks.length > 0) {
                if (!confirm('Switching modes will delete all custom base blocks. Continue?')) {
                    e.target.value = editorState.baseMode; // Revert selection
                    return;
                }
                editorState.baseBlocks = []; // Clear custom base blocks
            }
            
            editorState.baseMode = newMode;
            const simpleSettings = document.getElementById('simpleBaseSettings');
            const advancedSettings = document.getElementById('advancedBaseSettings');
            simpleSettings.style.display = newMode === 'simple' ? 'block' : 'none';
            advancedSettings.style.display = newMode === 'advanced' ? 'block' : 'none';
            renderEditorCanvas();
        });

        // Base Sides Handler (for simple mode)
        document.getElementById('baseSidesInput').addEventListener('input', (e) => {
            editorState.baseSides = Math.max(3, Math.min(16, parseInt(e.target.value) || 4));
            renderEditorCanvas();
        });

        // Tank Stats Handlers
        document.getElementById('tankLevelInput').addEventListener('input', (e) => {
            editorState.level = Math.max(1, Math.min(45, parseInt(e.target.value) || 1));
        });

        document.getElementById('tankFovInput').addEventListener('input', (e) => {
            editorState.fov = Math.max(0.5, Math.min(2, parseFloat(e.target.value) || 1));
        });

        // Add Blade Button
        document.getElementById('addBladeBtn').addEventListener('click', () => {
            const newBlade = {
                id: Date.now(),
                shape: 4, // square
                size: 1.5,
                x: 0,
                y: 0,
                rotation: 0,
                layer: 0,
                color: '#999999'
            };
            editorState.blades.push(newBlade);
            editorState.selectedBlade = newBlade;
            editorState.selectedBlock = null;
            editorState.selectedBaseBlock = null;
            editorState.selectedType = 'blade';
            updateBladesList();
            updatePropertiesPanel();
            renderEditorCanvas();
        });

        // Add Base Block Button (for advanced mode)
        document.getElementById('addBaseBlockBtn').addEventListener('click', () => {
            const newBaseBlock = {
                id: Date.now(),
                shape: 0, // 0 = circle
                size: 20,
                x: 0,
                y: 0,
                width: 20,
                height: 20,
                rotation: 0,
                layer: 0,
                color: '#00b2e1'
            };
            editorState.baseBlocks.push(newBaseBlock);
            editorState.selectedBaseBlock = newBaseBlock;
            editorState.selectedBlock = null;
            editorState.selectedBlade = null;
            editorState.selectedType = 'baseBlock';
            updateBaseBlocksList();
            updatePropertiesPanel();
            renderEditorCanvas();
        });

        document.getElementById('editorCancelBtn').addEventListener('click', () => {
            if (confirm('Are you sure? This will delete your current tank design.')) {
                editorState = {
                    blocks: [],
                    selectedBlock: null,
                    selectedBlade: null,
                    selectedBaseBlock: null,
                    selectedType: null,
                    rotation: 0,
                    zoom: 1,
                    dragging: false,
                    lastMousePos: { x: 0, y: 0 },
                    level: 1,
                    fov: 1,
                    baseMode: 'none',
                    baseSides: 4,
                    baseBlocks: [],
                    blades: []
                };
                updateCurrentBlocksList();
                updateBladesList();
                updateBaseBlocksList();
                updatePropertiesPanel();
                renderEditorCanvas();
                
                // Close editor and return to main menu
                document.getElementById('tankEditor').style.display = 'none';
                document.getElementById('startMenu').classList.remove('hidden');
            }
        });

        document.getElementById('editorSaveBtn').addEventListener('click', () => {
            // Populate tank selector
            const tankSelectorGrid = document.getElementById('tankSelectorGrid');
            tankSelectorGrid.innerHTML = '';
            
            const selectedTanks = new Set();
            
            // Sort tanks by level
            const sortedTanks = Object.entries(tankTypes).sort((a, b) => a[1].level - b[1].level);
            
            sortedTanks.forEach(([tankKey, tank]) => {
                if (tankKey.startsWith('__')) return; // Skip temporary tanks
                
                const tankBtn = document.createElement('div');
                tankBtn.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 8px; background: #2a2a2a; border: 2px solid #444; border-radius: 4px; cursor: pointer; transition: all 0.2s;';
                tankBtn.dataset.tankKey = tankKey;
                
                // Mini preview canvas
                const miniCanvas = document.createElement('canvas');
                miniCanvas.width = 40;
                miniCanvas.height = 40;
                const miniCtx = miniCanvas.getContext('2d');
                
                // Draw tank preview
                miniCtx.save();
                miniCtx.translate(20, 20);
                miniCtx.fillStyle = '#00b2e1';
                miniCtx.beginPath();
                miniCtx.arc(0, 0, 12, 0, Math.PI * 2);
                miniCtx.fill();
                
                // Draw simplified guns
                if (tank.guns) {
                    tank.guns.forEach(gun => {
                        miniCtx.save();
                        miniCtx.rotate((gun.angle || 0) * Math.PI / 180);
                        miniCtx.fillStyle = gun.color || '#999';
                        miniCtx.fillRect(-gun.width/4 || -2, 12, gun.width/2 || 4, gun.length/2 || 10);
                        miniCtx.restore();
                    });
                }
                miniCtx.restore();
                
                tankBtn.appendChild(miniCanvas);
                
                // Tank info
                const infoDiv = document.createElement('div');
                infoDiv.style.cssText = 'flex: 1;';
                infoDiv.innerHTML = `
                    <div style="font-weight: bold; font-size: 12px;">${tank.name}</div>
                    <div style="color: #aaa; font-size: 11px;">Level ${tank.level}</div>
                `;
                tankBtn.appendChild(infoDiv);
                
                tankBtn.addEventListener('click', () => {
                    if (selectedTanks.has(tankKey)) {
                        selectedTanks.delete(tankKey);
                        tankBtn.style.borderColor = '#444';
                        tankBtn.style.background = '#2a2a2a';
                    } else {
                        selectedTanks.add(tankKey);
                        tankBtn.style.borderColor = '#44ff44';
                        tankBtn.style.background = '#1a3a1a';
                    }
                    
                    // Update input field
                    document.getElementById('saveTankUpgrades').value = Array.from(selectedTanks).join(', ');
                });
                
                tankSelectorGrid.appendChild(tankBtn);
            });
            
            document.getElementById('saveTankModal').style.display = 'flex';
        });

        document.getElementById('saveTankCancelBtn').addEventListener('click', () => {
            document.getElementById('saveTankModal').style.display = 'none';
        });

        document.getElementById('saveTankConfirmBtn').addEventListener('click', () => {
            const name = document.getElementById('saveTankName').value.trim().toUpperCase();
            const level = parseInt(document.getElementById('saveTankLevel').value) || 1;
            const upgradesFrom = document.getElementById('saveTankUpgrades').value.trim();
            const hideFromTree = document.getElementById('saveTankHideFromTree').checked;
            
            if (!name) {
                alert('Please enter a tank name!');
                return;
            }

            // Convert blocks to tank config format
            const guns = editorState.blocks.map(block => ({
                type: block.type,
                ...block.props
            }));

            const tankConfig = {
                name: name,
                level: level,
                guns: guns,
                hideFromTree: hideFromTree
            };
            
            // Add baseShape if using simple mode
            if (editorState.baseMode === 'simple') {
                tankConfig.baseShape = editorState.baseSides;
            } else if (editorState.baseMode === 'advanced') {
                tankConfig.baseShape = 'advanced';
            }
            
            // Add advanced base blocks if in advanced mode
            if (editorState.baseMode === 'advanced' && editorState.baseBlocks.length > 0) {
                tankConfig.baseBlocks = editorState.baseBlocks.map(block => ({
                    shape: block.shape,
                    size: block.size,
                    x: block.x,
                    y: block.y,
                    width: block.width,
                    height: block.height,
                    rotation: block.rotation,
                    layer: block.layer,
                    color: block.color
                }));
            }
            
            // Add blades if any
            if (editorState.blades.length > 0) {
                tankConfig.blades = editorState.blades.map(blade => ({
                    shape: blade.shape,
                    size: blade.size,
                    x: blade.x,
                    y: blade.y,
                    rotation: blade.rotation,
                    layer: blade.layer,
                    color: blade.color
                }));
            }
            
            // Add FOV if set
            if (editorState.fov) {
                tankConfig.fov = editorState.fov;
            }

            const upgradePaths = upgradesFrom ? upgradesFrom.split(',').map(s => s.trim().toUpperCase()) : [];

            console.log('Saving tank:', tankConfig);
            console.log('Upgrade paths:', upgradePaths);
            
            // Send to server for saving
            fetch('https://ronny-io.onrender.com/saveTank', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tankConfig, upgradePaths })
            }).then(res => res.json())
              .then(data => {
                  if (data.success) {
                      alert('Tank saved successfully!');
                  } else {
                      alert('Error saving tank: ' + (data.error || 'Unknown error'));
                  }
              })
              .catch(err => {
                  alert('Error saving tank: ' + err.message);
              });
            
            document.getElementById('saveTankModal').style.display = 'none';
            document.getElementById('tankEditor').style.display = 'none';
            
            editorState = {
                blocks: [],
                selectedBlock: null,
                rotation: 0,
                zoom: 1,
                dragging: false,
                lastMousePos: { x: 0, y: 0 }
            };
        });

        // Export to JSON button - Copy tank config to clipboard
        document.getElementById('editorExportJSONBtn').addEventListener('click', () => {
            // Determine baseShape from baseMode
            let baseShape = 'circle';
            if (editorState.baseMode === 'simple') {
                baseShape = editorState.baseSides; // Use number directly
            } else if (editorState.baseMode === 'advanced') {
                baseShape = 'advanced'; // Special marker for custom base
            }
            
            const tankConfig = {
                name: "Custom Tank",
                level: editorState.level || 1,
                baseShape: baseShape,
                guns: editorState.blocks.map(block => {
                    const gun = { ...block.props };
                    // Remove knockback property
                    delete gun.knockback;
                    
                    // For advanced bases, "bake" the gun position and rotation based on editor preview
                    if (editorState.baseMode === 'advanced' && gun.angle !== undefined) {
                        // Use the exact same calculation as editor preview
                        const baked = calculateBakedGunTransform(gun);
                        
                        // Set baked values
                        gun.offsetX = baked.x;
                        gun.offsetY = baked.y;
                        gun.rotation = baked.rotation * 180 / Math.PI;
                        gun.angle = 0;
                        
                        // Remove properties that are now baked
                        delete gun.blockRotation;
                        delete gun.selfAngle;
                    }
                    
                    return gun;
                }),
                fov: editorState.fov || 1,
                upgrades: []
            };
            
            // Add advanced base blocks if in advanced mode
            if (editorState.baseMode === 'advanced' && editorState.baseBlocks.length > 0) {
                tankConfig.baseBlocks = editorState.baseBlocks.map(block => ({
                    shape: block.shape,
                    size: block.size,
                    x: block.x,
                    y: block.y,
                    width: block.width || 0,
                    height: block.height || 0,
                    rotation: block.rotation || 0,
                    layer: block.layer || 0,
                    color: block.color
                }));
            }
            
            // Add blades if any
            if (editorState.blades.length > 0) {
                const bladeDamage = parseFloat(document.getElementById('bladeDamageMultiplier').value) || 1;
                tankConfig.blades = editorState.blades.map(blade => ({
                    shape: blade.shape,
                    size: blade.size,
                    x: blade.x || 0,
                    y: blade.y || 0,
                    rotation: blade.rotation || 0,
                    layer: blade.layer || 0,
                    color: blade.color
                }));
                if (bladeDamage !== 1) {
                    tankConfig.bladeDamageMultiplier = bladeDamage;
                }
            }
            
            // Format JSON nicely
            const jsonString = JSON.stringify(tankConfig, null, 2);
            
            // Copy to clipboard
            navigator.clipboard.writeText(jsonString).then(() => {
                // Show success feedback
                const btn = document.getElementById('editorExportJSONBtn');
                const originalText = btn.textContent;
                btn.textContent = 'âœ“ Copied!';
                btn.style.background = '#44ff44';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#ff9500';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy to clipboard:', err);
                alert('Failed to copy to clipboard. Check console for JSON output.');
                console.log('Tank JSON:', jsonString);
            });
        });

        // Test Area - Spawn into game with temporary tank
        document.getElementById('editorTestBtn').addEventListener('click', () => {
            console.log('[TEST MODE] Test button clicked');
            
            // Create temporary tank config matching tankUpgrades.json format
            const testTankName = '__TEST_TANK__' + Date.now();
            
            // Determine baseShape from baseMode
            let baseShape = 'circle';
            if (editorState.baseMode === 'simple') {
                baseShape = editorState.baseSides; // Use number directly
            } else if (editorState.baseMode === 'advanced') {
                baseShape = 'advanced'; // Special marker for custom base
            }
            
            const testTankConfig = {
                name: 'Test Tank',
                level: editorState.level || 1,
                baseShape: baseShape,
                guns: editorState.blocks.map(block => {
                    const gun = { ...block.props };
                    
                    // For advanced bases, "bake" the gun position and rotation based on editor preview
                    if (editorState.baseMode === 'advanced' && gun.angle !== undefined) {
                        // Use the exact same calculation as editor preview
                        const baked = calculateBakedGunTransform(gun);
                        
                        // Set baked values
                        gun.offsetX = baked.x;
                        gun.offsetY = baked.y;
                        gun.rotation = baked.rotation * 180 / Math.PI;
                        gun.angle = 0;
                        
                        // Remove properties that are now baked
                        delete gun.blockRotation;
                        delete gun.selfAngle;
                    }
                    
                    return gun;
                }),
                fov: editorState.fov || 1,
                hideFromTree: true
            };
            
            // Add advanced base blocks if in advanced mode
            if (editorState.baseMode === 'advanced' && editorState.baseBlocks.length > 0) {
                testTankConfig.baseBlocks = editorState.baseBlocks.map(block => ({
                    shape: block.shape,
                    size: block.size,
                    x: block.x,
                    y: block.y,
                    width: block.width,
                    height: block.height,
                    rotation: block.rotation,
                    layer: block.layer,
                    color: block.color
                }));
            }
            
            // Add blades if any
            if (editorState.blades.length > 0) {
                testTankConfig.blades = editorState.blades.map(blade => ({
                    shape: blade.shape,
                    size: blade.size,
                    x: blade.x,
                    y: blade.y,
                    rotation: blade.rotation,
                    layer: blade.layer,
                    color: blade.color
                }));
            }
            
            console.log('[TEST MODE] Created tank config:', testTankConfig);
            console.log('[TEST MODE] Tank name:', testTankName);
            console.log('[TEST MODE] Current playerId:', playerId);
            
            // Send test tank to server and wait for confirmation
            console.log('[TEST MODE] Sending setTestTank to server...');
            socket.emit('setTestTank', { tankName: testTankName, config: testTankConfig });
            
            // Add to local tankTypes
            tankTypes[testTankName] = testTankConfig;
            console.log('[TEST MODE] Added to local tankTypes');
            
            // Hide editor, show game
            document.getElementById('tankEditor').style.display = 'none';
            document.getElementById('startMenu').classList.add('hidden');
            document.getElementById('hud').classList.add('visible');
            console.log('[TEST MODE] UI updated');
            
            // Wait for server to confirm tank registration before joining
            const testTankRegisteredHandler = () => {
                console.log('[TEST MODE] Server confirmed tank registration, joining game...');
                
                // Join game with test tank
                socket.emit('joinGame', 'Test Player');
                
                // Wait for playerJoined event, then upgrade to test tank
                const joinHandler = (data) => {
                    console.log('[TEST MODE] Player joined, received data:', data);
                    playerId = data.id;
                    console.log('[TEST MODE] Set playerId to:', playerId);
                    console.log('[TEST MODE] Waiting 500ms before upgrading...');
                    setTimeout(() => {
                        console.log('[TEST MODE] Sending upgradeTank request for:', testTankName);
                        socket.emit('upgradeTank', testTankName);
                    }, 500);
                    socket.off('playerJoined', joinHandler);
                };
                socket.on('playerJoined', joinHandler);
                
                // Remove this one-time listener
                socket.off('testTankRegistered', testTankRegisteredHandler);
            };
            
            socket.on('testTankRegistered', testTankRegisteredHandler);
            
            // Setup exit handler - Press ESC to exit test mode
            const exitHandler = (e) => {
                if (e && e.key !== 'Escape') return;
                
                console.log('[TEST MODE] Exiting test mode...');
                
                // Leave game (despawn)
                if (playerId) {
                    console.log('[TEST MODE] Leaving game');
                    socket.emit('playerLeaveGame');
                    playerId = null;
                }
                
                // Clean up test tank from server after a delay to allow game loop to finish
                setTimeout(() => {
                    console.log('[TEST MODE] Clearing test tank from server');
                    socket.emit('clearTestTank', testTankName);
                    
                    // Clean up local test tank
                    delete tankTypes[testTankName];
                }, 500);
                
                // Return to builder (stay despawned)
                document.getElementById('hud').classList.remove('visible');
                document.getElementById('startMenu').classList.add('hidden');
                document.getElementById('tankEditor').style.display = 'block';
                
                // Remove event listener
                window.removeEventListener('keydown', exitHandler);
                
                console.log('[TEST MODE] Returned to builder (despawned)');
            };
            
            // Add ESC key listener
            window.addEventListener('keydown', exitHandler);
            
            // Show instruction
            setTimeout(() => {
                console.log('[TEST MODE] Press ESC to return to builder');
            }, 500);
        });
    </script>
</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RONNY IO - Multiplayer Tank Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #e0e0e0;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            background: #d8d8d8;
            image-rendering: crisp-edges;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
        }

        #startMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #startMenu.hidden {
            display: none;
        }

        .menu-content {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        .menu-title {
            font-size: 72px;
            font-weight: bold;
            color: white;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            margin-bottom: 30px;
        }

        #nameInput {
            font-size: 24px;
            padding: 15px 30px;
            border: none;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            border-radius: 10px;
            margin-bottom: 20px;
            width: 300px;
            text-align: center;
            outline: none;
        }

        #playButton {
            font-size: 28px;
            padding: 15px 60px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        #playButton:hover {
            background: #45a049;
            transform: scale(1.05);
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            display: none; /* Hidden by default */
        }

        #hud.visible {
            display: block;
        }

        .hud-item {
            margin-bottom: 5px;
        }

        .health-bar {
            width: 200px;
            height: 25px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50px;
            overflow: hidden;
            margin-top: 5px;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF4444, #FF8888);
            transition: width 0.3s;
            border-radius: 50px;
        }

        .xp-bar {
            width: 300px;
            height: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50px;
            overflow: hidden;
            margin-top: 5px;
        }

        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            transition: width 0.3s;
            border-radius: 50px;
        }

        #upgradeMenu {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            color: white;
            max-width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            z-index: 200;
        }

        #upgradeMenu::-webkit-scrollbar {
            width: 8px;
        }

        #upgradeMenu::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        #upgradeMenu::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 4px;
        }

        #upgradeMenu::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.7);
        }

        #upgradeMenu.visible {
            display: block;
        }

        .upgrade-section {
            margin-bottom: 20px;
        }

        .upgrade-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
            border-bottom: 2px solid white;
            padding-bottom: 5px;
        }

        .stat-upgrade {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .stat-upgrade:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .stat-upgrade.maxed {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .stat-bars {
            display: flex;
            gap: 2px;
        }

        .stat-bar {
            width: 15px;
            height: 15px;
            background: rgba(255, 255, 255, 0.3);
            border: 1px solid white;
        }

        .stat-bar.filled {
            background: #FFD700;
        }

        .tank-upgrade {
            background: rgba(100, 150, 255, 0.3);
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .tank-upgrade:hover:not(.locked) {
            background: rgba(100, 150, 255, 0.5);
            border-color: white;
            transform: scale(1.02);
        }

        .tank-upgrade.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #tankUpgrades {
            max-height: 200px;
            overflow-y: auto;
        }

        #tankUpgrades::-webkit-scrollbar {
            width: 6px;
        }

        #tankUpgrades::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        #tankUpgrades::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 3px;
        }

        .tank-name {
            font-weight: bold;
            font-size: 16px;
        }

        .tank-level {
            font-size: 12px;
            color: #FFD700;
        }

        #leaderboard {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            min-width: 200px;
            margin-bottom: 10px;
        }

        #leaderboard.hidden {
            display: none;
        }

        .leaderboard-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 2px solid white;
            padding-bottom: 5px;
        }

        .leaderboard-entry {
            padding: 5px;
            margin: 3px 0;
            font-size: 14px;
        }

        .leaderboard-entry:nth-child(2) {
            color: #FFD700;
        }

        .leaderboard-entry:nth-child(3) {
            color: #C0C0C0;
        }

        .leaderboard-entry:nth-child(4) {
            color: #CD7F32;
        }

        #chatContainer {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 230px;
            z-index: 100;
        }

        #chatMessages {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 10px;
            color: white;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .chat-message {
            margin: 3px 0;
            word-wrap: break-word;
        }

        #chatInputBox {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #555;
            border-radius: 5px;
            color: white;
            font-size: 14px;
            box-sizing: border-box;
        }

        #chatInputBox:focus {
            outline: none;
            border-color: #00B2E1;
        }

        #minimap {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid white;
            border-radius: 50%;
            overflow: hidden;
        }

        .controls-help {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 14px;
            z-index: 100;
        }

        .controls-help.hidden {
            display: none;
        }

        .control-item {
            margin: 5px 0;
        }

        .control-item.active {
            color: #4CAF50;
            font-weight: bold;
        }

        #deathScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 500;
        }

        #deathScreen.visible {
            display: flex;
        }

        .death-content {
            text-align: center;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 40px;
            border-radius: 20px;
        }

        .death-title {
            font-size: 48px;
            font-weight: bold;
            color: #FF4444;
            margin-bottom: 20px;
        }

        .killed-by {
            font-size: 24px;
            margin: 10px 0;
        }

        .killer-name {
            color: #FFD700;
            font-weight: bold;
        }

        .respawn-timer {
            font-size: 18px;
            margin-top: 20px;
            color: #888;
        }

        .upgrade-points {
            font-size: 14px;
            color: #FFD700;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="startMenu">
        <div class="menu-content">
            <div class="menu-title">RONNY IO</div>
            <input type="text" id="nameInput" placeholder="Enter your name" maxlength="20">
            <br>
            <button id="playButton">PLAY</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="hud">
        <div class="hud-item">Score: <span id="score">0</span></div>
        <div class="hud-item">Level: <span id="level">1</span></div>
        <div class="health-bar">
            <div class="health-fill" id="healthFill"></div>
        </div>
        <div class="xp-bar">
            <div class="xp-fill" id="xpFill"></div>
        </div>
        
        <!-- Minimap -->
        <canvas id="minimap" width="150" height="150" style="position: absolute; left: 10px; top: 120px; border: 3px solid #404040; border-radius: 5px; background: rgba(0, 0, 0, 0.5);"></canvas>
    </div>

    <div id="upgradeMenu">
        <div class="upgrade-section">
            <div class="upgrade-title">Stats</div>
            <div id="upgradePointsDisplay" style="color: #ffd700; font-size: 16px; font-weight: bold; margin-bottom: 10px; text-align: center;">Upgrade Points: 0</div>
            <div id="statUpgrades"></div>
            <button id="viewUpgradeTreeBtn" style="display: none; margin-top: 10px; padding: 8px 16px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">View Full Upgrade Tree</button>
        </div>
        <div class="upgrade-section" id="tankUpgradeSection" style="display: none;">
            <div class="upgrade-title">Tank Upgrades</div>
            <div id="tankUpgrades"></div>
        </div>
    </div>

    <div id="upgradeTreeModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; overflow: auto;">
        <div style="position: relative; width: 100%; min-height: 100%; padding: 40px;">
            <button id="closeUpgradeTreeBtn" style="position: fixed; top: 20px; right: 20px; padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; z-index: 10001;">Close</button>
            <div style="position: fixed; top: 20px; left: 20px; z-index: 10001; display: flex; gap: 10px;">
                <button id="zoomInTreeBtn" style="padding: 10px 15px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">+</button>
                <button id="zoomOutTreeBtn" style="padding: 10px 15px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">-</button>
                <button id="resetTreeBtn" style="padding: 10px 15px; background: #44ff44; color: black; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Reset</button>
            </div>
            <canvas id="upgradeTreeCanvas" style="background: #2a2a2a; border-radius: 8px; display: block; margin: 0 auto;"></canvas>
        </div>
    </div>

    <div id="chatContainer">
        <div id="leaderboard">
            <div class="leaderboard-title">Leaderboard</div>
            <div id="leaderboardList"></div>
        </div>
        <div id="chatMessages"></div>
        <input type="text" id="chatInputBox" placeholder="Press Enter to chat..." maxlength="100">
    </div>

    <div class="controls-help hidden" id="controlsHelp">
        <div class="control-item" id="controlWASD"><strong>WASD</strong> - Move</div>
        <div class="control-item" id="controlMouse"><strong>Mouse</strong> - Aim</div>
        <div class="control-item" id="controlClick"><strong>Click</strong> - Shoot</div>
        <div class="control-item" id="controlE"><strong>E</strong> - Auto Fire</div>
        <div class="control-item" id="controlI"><strong>I</strong> - Toggle Upgrades</div>
        <div class="control-item" id="controlH"><strong>H</strong> - Hold for Help</div>
    </div>

    <div id="cheatPanel" style="display: none; position: absolute; bottom: 10px; left: 10px; background: rgba(255, 0, 0, 0.8); color: white; padding: 15px; border-radius: 10px; font-size: 14px; z-index: 1000;">
        <div style="font-weight: bold; margin-bottom: 10px;">ðŸ”§ ADMIN PANEL ACTIVE</div>
        <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px;">
            <strong>Shift+G</strong> - Give XP: 
            <button id="decreaseXP" style="padding: 2px 8px; background: #ff4444; color: white; border: none; border-radius: 3px; cursor: pointer; font-weight: bold;">-</button>
            <span id="xpAmount" style="min-width: 60px; text-align: center; font-weight: bold;">100</span>
            <button id="increaseXP" style="padding: 2px 8px; background: #44ff44; color: white; border: none; border-radius: 3px; cursor: pointer; font-weight: bold;">+</button>
        </div>
        <div><strong>Shift+B</strong> - Max Stats (Level 1000)</div>
        <div><strong>Shift+I</strong> - Toggle Invincibility</div>
        <div style="display: flex; align-items: center; gap: 5px;">
            <div><strong>Shift+T</strong> - Teleport</div>
            <button id="tpModeAll" style="padding: 2px 8px; background: #44ff44; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">All</button>
            <button id="tpModeOthers" style="padding: 2px 8px; background: #666; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Others</button>
            <button id="tpModeYou" style="padding: 2px 8px; background: #666; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">You</button>
        </div>
        <div><strong>Shift+C</strong> - Clear All Polygons</div>
        <div><strong>Shift+A</strong> - Morph to ADMIN Tank</div>
        <div style="display: flex; align-items: center; gap: 5px; margin-top: 5px;">
            <strong>Shift+1</strong> - Spawn: 
            <button id="prevPolygon" style="padding: 2px 8px; background: #ff4444; color: white; border: none; border-radius: 3px; cursor: pointer; font-weight: bold;">â—€</button>
            <span id="polygonDisplay" style="min-width: 150px; text-align: center; font-weight: bold;">Triangle (Tier 1)</span>
            <button id="nextPolygon" style="padding: 2px 8px; background: #44ff44; color: white; border: none; border-radius: 3px; cursor: pointer; font-weight: bold;">â–¶</button>
        </div>
        <div><strong>9</strong> - Spawn All Polygon Types at Cursor</div>
        <div><strong>Shift+R</strong> - Reset Tank & Upgrades</div>
        <div><strong>ESC</strong> - Close Panel</div>
        <button id="openTankEditorBtn" style="margin-top: 10px; padding: 5px 10px; background: #ff9500; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%; font-weight: bold;">ðŸŽ¨ Tank Editor</button>
        <button id="viewUpgradeTreeCheat" style="margin-top: 10px; padding: 5px 10px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%;">View Upgrade Tree (Click to Morph)</button>
    </div>


    <div id="deathScreen">
        <div class="death-content">
            <div class="death-title">YOU DIED</div>
            <div id="killedByList"></div>
            <div class="respawn-timer">Respawning...</div>
        </div>
    </div>

    <!-- Tank Editor -->
    <div id="tankEditor" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a1a; z-index: 20000;">
        <!-- Left Panel - Block Menu & Settings -->
        <div id="editorLeftPanel" style="position: absolute; left: 0; top: 0; width: 250px; height: 100%; background: #2a2a2a; border-right: 2px solid #444; overflow-y: auto; padding: 15px; box-sizing: border-box; display: flex; flex-direction: column; gap: 20px;">
            <!-- Current Guns Section -->
            <div style="flex-shrink: 0;">
                <h2 style="color: #fff; margin-top: 0; margin-bottom: 15px;">Current Guns</h2>
                <div id="currentBlocksList" style="display: flex; flex-direction: column; gap: 6px; max-height: 200px; overflow-y: auto;">
                    <div style="color: #888; font-size: 12px; font-style: italic;">No guns added yet</div>
                </div>
            </div>
            
            <!-- Add Guns Section -->
            <div style="flex-shrink: 0; border-top: 2px solid #444; padding-top: 15px;">
                <h2 style="color: #fff; margin-top: 0; margin-bottom: 15px;">Add Gun</h2>
                <div id="gunBlocksList" style="display: flex; flex-direction: column; gap: 8px;"></div>
            </div>
            
            <!-- Tank Settings Section -->
            <div style="flex-shrink: 0; border-top: 2px solid #444; padding-top: 15px;">
                <h2 style="color: #fff; margin-top: 0; margin-bottom: 15px;">Tank Settings</h2>
                
                <!-- Tank Level -->
                <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 13px;">Level Required:</label>
                <input type="number" id="tankLevelInput" min="1" max="45" value="1" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; margin-bottom: 10px;">
                
                <!-- FOV -->
                <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 13px;">Field of View (FOV):</label>
                <input type="number" id="tankFovInput" min="0.5" max="2" step="0.1" value="1" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; margin-bottom: 15px;">
                
                <!-- Base Shape Mode -->
                <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 13px;">Base Mode:</label>
                <select id="baseModeSelect" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; margin-bottom: 10px;">
                    <option value="none">None (Circle)</option>
                    <option value="simple">Simple (Polygon)</option>
                    <option value="advanced">Advanced (Custom)</option>
                </select>
                
                <!-- Simple Base Settings (shown only for simple mode) -->
                <div id="simpleBaseSettings" style="display: none;">
                    <label style="display: block; margin-bottom: 5px; color: #aaa; font-size: 13px;">Number of Sides:</label>
                    <input type="number" id="baseSidesInput" min="3" max="16" value="4" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; margin-bottom: 10px;">
                </div>
                
                <!-- Advanced Base Settings (shown only for advanced mode) -->
                <div id="advancedBaseSettings" style="display: none;">
                    <h3 style="color: #fff; margin: 10px 0 5px 0; font-size: 14px;">Base Blocks:</h3>
                    <div id="baseBlocksList" style="display: flex; flex-direction: column; gap: 6px; max-height: 150px; overflow-y: auto; margin-bottom: 10px;">
                        <div style="color: #888; font-size: 12px; font-style: italic;">No base blocks added</div>
                    </div>
                    <button id="addBaseBlockBtn" style="width: 100%; padding: 8px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">+ Add Base Block</button>
                </div>
                
                <!-- Blade Settings -->
                <div style="border-top: 2px solid #444; margin-top: 15px; padding-top: 15px;">
                    <h3 style="color: #fff; margin-top: 0; margin-bottom: 10px; font-size: 14px;">Blades:</h3>
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; color: #aaa; font-size: 12px; margin-bottom: 5px;">Blade Damage Multiplier:</label>
                        <input id="bladeDamageMultiplier" type="number" step="0.1" value="1" min="0" style="width: 100%; padding: 6px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; box-sizing: border-box;">
                    </div>
                    <div id="bladesList" style="display: flex; flex-direction: column; gap: 6px; max-height: 200px; overflow-y: auto; margin-bottom: 10px;">
                        <div style="color: #888; font-size: 12px; font-style: italic;">No blades added</div>
                    </div>
                    <button id="addBladeBtn" style="width: 100%; padding: 8px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">+ Add Blade</button>
                </div>
                
                <!-- Import/Export Section -->
                <div style="border-top: 2px solid #444; margin-top: 15px; padding-top: 15px;">
                    <h3 style="color: #fff; margin-top: 0; margin-bottom: 10px; font-size: 14px;">Import/Export:</h3>
                    <button id="importJsonBtn" style="width: 100%; padding: 8px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; margin-bottom: 8px;">Import from Clipboard</button>
                </div>
            </div>
        </div>

        <!-- Center Panel - Visual Editor -->
        <div id="editorCenterPanel" style="position: absolute; left: 250px; top: 0; right: 300px; height: 100%; background: #1a1a1a; display: flex; flex-direction: column;">
            <div style="background: #2a2a2a; padding: 15px; border-bottom: 2px solid #444; display: flex; justify-content: space-between; align-items: center;">
                <h1 style="color: #fff; margin: 0;">Tank Editor</h1>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <label style="color: #aaa; font-size: 13px; display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="checkbox" id="debugPerimeterToggle" style="cursor: pointer;">
                        Show Perimeter Debug
                    </label>
                    <label style="color: #aaa; font-size: 13px; display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="checkbox" id="freezeDebugToggle" style="cursor: pointer;">
                        Freeze Debug
                    </label>
                    <label style="color: #aaa; font-size: 13px; display: flex; align-items: center; gap: 5px;">
                        Scale Divisor:
                        <input type="number" id="debugScaleDivisor" value="2" min="0.1" step="0.1" style="width: 60px; padding: 2px 5px; background: #2a2a2a; color: white; border: 1px solid #555; border-radius: 3px;">
                    </label>
                    </label>
                    <button id="editorExportJSONBtn" style="padding: 10px 20px; background: #ff9500; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">ðŸ“‹ Export JSON</button>
                    <button id="editorTestBtn" style="padding: 10px 20px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Test</button>
                    <button id="editorCancelBtn" style="padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Cancel</button>
                    <button id="editorSaveBtn" style="padding: 10px 20px; background: #44ff44; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Save</button>
                </div>
            </div>
            <div style="flex: 1; position: relative; overflow: hidden;">
                <canvas id="editorCanvas" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #0f0f0f; cursor: grab;"></canvas>
            </div>
        </div>

        <!-- Right Panel - Properties -->
        <div id="editorRightPanel" style="position: absolute; right: 0; top: 0; width: 300px; height: 100%; background: #2a2a2a; border-left: 2px solid #444; overflow-y: auto; padding: 15px; box-sizing: border-box;">
            <h2 style="color: #fff; margin-top: 0; margin-bottom: 15px;">Properties</h2>
            <div id="editorPropertiesContent" style="color: #aaa; font-size: 14px;">
                Select a block to edit its properties
            </div>
        </div>
    </div>

    <!-- Save Tank Modal -->
    <div id="saveTankModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 30000; justify-content: center; align-items: center;">
        <div style="background: #2a2a2a; padding: 30px; border-radius: 10px; max-width: 700px; width: 90%; max-height: 90vh; overflow-y: auto; color: white;">
            <h2 style="margin-top: 0;">Save Tank</h2>
            
            <label style="display: block; margin-bottom: 5px; color: #aaa;">Tank Name:</label>
            <input id="saveTankName" type="text" placeholder="Enter tank name" style="width: 100%; padding: 10px; margin-bottom: 15px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; box-sizing: border-box;">
            
            <label style="display: block; margin-bottom: 5px; color: #aaa;">Required Level:</label>
            <input id="saveTankLevel" type="number" value="1" min="1" style="width: 100%; padding: 10px; margin-bottom: 15px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; box-sizing: border-box;">
            
            <label style="display: block; margin-bottom: 5px; color: #aaa;">Upgrade From (click tanks to add):</label>
            <input id="saveTankUpgrades" type="text" placeholder="Selected tanks will appear here" readonly style="width: 100%; padding: 10px; margin-bottom: 10px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; box-sizing: border-box; cursor: default;">
            
            <div id="tankSelectorGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; max-height: 300px; overflow-y: auto; margin-bottom: 15px; padding: 10px; background: #1a1a1a; border-radius: 4px;">
                <!-- Tank selector buttons will be populated here -->
            </div>
            
            <label style="display: flex; align-items: center; margin-bottom: 15px; cursor: pointer;">
                <input id="saveTankHideFromTree" type="checkbox" style="margin-right: 10px;">
                <span>Hide from upgrade tree</span>
            </label>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="saveTankCancelBtn" style="padding: 10px 20px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                <button id="saveTankConfirmBtn" style="padding: 10px 20px; background: #44ff44; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">Save</button>
            </div>
        </div>
    </div>

    <!-- Test Area (overlays the game for testing) -->
    <div id="testArea" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 25000; pointer-events: none;">
        <div style="position: absolute; top: 20px; right: 20px; z-index: 1; pointer-events: all;">
            <button id="exitTestBtn" style="padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold;">Exit Test</button>
        </div>
        <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(255, 149, 0, 0.9); color: white; padding: 10px 20px; border-radius: 4px; font-weight: bold; pointer-events: none;">
            ðŸŽ¨ TESTING TANK - Click "Exit Test" when done
        </div>
    </div>

    <!-- Load Socket.IO from CDN for GitHub Pages compatibility -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Server URL - Codespace forwarded URL
        // When running in Codespace: https://CODESPACE_NAME-3000.app.github.dev
        // For local testing: http://localhost:3000
        const SERVER_URL = 'https://refactored-halibut-5g7pj676x5r34pq6-3000.app.github.dev';
        
        // Connect to server
        const socket = io(SERVER_URL, {
            transports: ['websocket', 'polling'],
            reconnection: true,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            reconnectionAttempts: Infinity
        });
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Game state
        let playerId = null;
        let gameState = null;
        let tankTypes = null;
        let tankUpgrades = null;
        let camera = { x: 0, y: 0, zoom: 1 };
        let targetCamera = { x: 0, y: 0 };
        let mouseWorldX = 0;
        let mouseWorldY = 0;
        let lastMouseScreenX = 0; // Track last screen mouse position
        let lastMouseScreenY = 0;
        let autoFire = false;
        let mouseDown = false;
        let upgradeMenuVisible = false;
        let showingHelp = false;
        let helpTimeout = null;
        let hasMovedOrShot = false;
        let keysPressed = {}; // Track which keys are currently pressed
        let lastKnownLevel = 0; // Track level to detect level ups
        let showAllHealthBars = false; // Toggle for showing all health bars (N key)
        
        // Cheat code tracking
        let cheatCodeBuffer = '';
        let cheatPanelActive = false;
        let xpAmount = 100; // Variable XP amount for give XP cheat
        
        // Polygon spawn system
        let selectedPolygonIndex = 0;
        const polygonTypes = [
            { sides: 3, name: 'Triangle', tier: 1 },
            { sides: 4, name: 'Square', tier: 1 },
            { sides: 5, name: 'Pentagon', tier: 2 },
            { sides: 6, name: 'Hexagon', tier: 2 },
            { sides: 8, name: 'Octagon', tier: 3 },
            { sides: 10, name: 'Decagon', tier: 3 },
            { sides: 12, name: 'Dodecagon', tier: 4 },
            { sides: 13, name: 'Tridecagon', tier: 4 },
            { sides: 14, name: 'Tetradecagon', tier: 5 },
            { sides: 15, name: 'Pentadecagon', tier: 5 },
            { sides: 16, name: 'Hexadecagon', tier: 5 }
        ];

        // Input state
        const input = {
            moving: { up: false, down: false, left: false, right: false },
            shooting: false,
            mouseX: 0,
            mouseY: 0
        };

        // Constants
        const MAP_RADIUS = 3000;
        const GRID_SIZE = 25; // More compact grid

        // Disable right-click context menu
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Disable browser zoom with Ctrl+/- and Ctrl+scroll
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '=')) {
                e.preventDefault();
            }
        });

        document.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
            }
        }, { passive: false });

        // Camera helper
        function setCameraSize(fov) {
            camera.zoom = 1 / fov;
        }

        function screenToWorld(screenX, screenY) {
            const worldX = (screenX - canvas.width / 2) / camera.zoom + camera.x;
            const worldY = (screenY - canvas.height / 2) / camera.zoom + camera.y;
            return { x: worldX, y: worldY };
        }

        function worldToScreen(worldX, worldY) {
            const screenX = (worldX - camera.x) * camera.zoom + canvas.width / 2;
            const screenY = (worldY - camera.y) * camera.zoom + canvas.height / 2;
            return { x: screenX, y: screenY };
        }

        // Calculate distance from center to edge of base at given angle
        function getBaseRadiusAtAngle(player, angle) {
            return getBaseRadiusAndFaceAtAngle(player, angle).radius;
        }

        // Get both radius and face angle at a specific angle
        function getBaseRadiusAndFaceAtAngle(player, angle) {
            const tankConfig = tankTypes[player.tankType];
            if (!tankConfig) return { radius: player.size, faceAngle: angle };
            
            // For circle or simple polygon base
            if (typeof tankConfig.baseShape === 'number') {
                const sides = tankConfig.baseShape;
                if (sides === 0) {
                    // Circle - constant radius, face perpendicular to radius
                    return { radius: player.size, faceAngle: angle };
                } else {
                    // Regular polygon - calculate distance to edge at this angle
                    const anglePerSide = (Math.PI * 2) / sides;
                    
                    // Cast a ray from origin at 'angle' and find intersection with polygon edges
                    const rayDx = Math.cos(angle);
                    const rayDy = Math.sin(angle);
                    
                    let minT = Infinity;
                    let intersectEdgeIndex = 0;
                    
                    // Check all edges
                    for (let i = 0; i < sides; i++) {
                        // Get the two vertices of this edge
                        const a1 = (i / sides) * Math.PI * 2 - Math.PI / 2;
                        const a2 = ((i + 1) / sides) * Math.PI * 2 - Math.PI / 2;
                        
                        const v1x = Math.cos(a1) * player.size;
                        const v1y = Math.sin(a1) * player.size;
                        const v2x = Math.cos(a2) * player.size;
                        const v2y = Math.sin(a2) * player.size;
                        
                        // Edge direction
                        const edgeDx = v2x - v1x;
                        const edgeDy = v2y - v1y;
                        
                        // Solve: origin + t * ray = v1 + s * edge
                        const denom = rayDx * edgeDy - rayDy * edgeDx;
                        if (Math.abs(denom) < 0.0001) continue; // Parallel
                        
                        const s = (rayDx * v1y - rayDy * v1x) / denom;
                        const t = (v1x * edgeDy - v1y * edgeDx) / denom;
                        
                        // Check if intersection is on the edge (0 <= s <= 1) and in front (t > 0)
                        if (s >= 0 && s <= 1 && t > 0 && t < minT) {
                            minT = t;
                            intersectEdgeIndex = i;
                        }
                    }
                    
                    const radius = minT < Infinity ? minT : player.size;
                    
                    // Calculate face angle (perpendicular to the edge)
                    const edgeMidAngle = (intersectEdgeIndex + 0.5) / sides * Math.PI * 2 - Math.PI / 2;
                    const faceAngle = edgeMidAngle;
                    
                    return { radius, faceAngle };
                }
            }
            
            // For advanced base, use conservative estimate (circle)
            return { radius: player.size, faceAngle: angle };
        }

        // Event listeners
        document.getElementById('playButton').addEventListener('click', () => {
            const name = document.getElementById('nameInput').value || 'Tank';
            socket.emit('joinGame', name);
            document.getElementById('startMenu').classList.add('hidden');
            document.getElementById('hud').classList.add('visible');
        });

        document.getElementById('nameInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('playButton').click();
            }
        });

        window.addEventListener('keydown', (e) => {
            // Only allow cheat code detection when in game
            if (!playerId && !cheatPanelActive) return;
            
            // Cheat code detection (only when in game)
            if (playerId && e.key.length === 1 && !cheatPanelActive) {
                cheatCodeBuffer += e.key.toLowerCase();
                if (cheatCodeBuffer.length > 20) {
                    cheatCodeBuffer = cheatCodeBuffer.slice(-20);
                }
                if (cheatCodeBuffer.includes('ronnyisskibidisigma')) {
                    // Send verification to server
                    socket.emit('verifyAdminCode', 'ronnyisskibidi');
                    cheatCodeBuffer = '';
                }
            }
            
            // Handle cheat panel commands (require Shift key)
            if (cheatPanelActive && e.shiftKey) {
                if (e.key === 'g' || e.key === 'G') {
                    socket.emit('cheatGiveXP', xpAmount);
                    return;
                }
                if (e.key === 'b' || e.key === 'B') {
                    socket.emit('cheatMaxStats');
                    return;
                }
                if (e.key === 'i' || e.key === 'I') {
                    socket.emit('cheatToggleInvincibility');
                    return;
                }
                if (e.key === 't' || e.key === 'T') {
                    socket.emit('cheatTeleportPlayers', { x: mouseWorldX, y: mouseWorldY, mode: teleportMode });
                    return;
                }
                if (e.key === 'c' || e.key === 'C') {
                    socket.emit('cheatClearPolygons');
                    console.log('Clearing all polygons...');
                    return;
                }
                if (e.key === 'a' || e.key === 'A') {
                    socket.emit('cheatMorphAdmin');
                    console.log('Morphing to ADMIN tank...');
                    return;
                }
                if (e.key === 'r' || e.key === 'R') {
                    socket.emit('cheatResetTank');
                    return;
                }
                // Shift+1 spawns selected polygon
                if (e.key === '!') {
                    const polygon = polygonTypes[selectedPolygonIndex];
                    console.log(`[POLYGON SPAWN] Spawning ${polygon.name} (${polygon.sides}-sided, tier ${polygon.tier})`);
                    socket.emit('cheatSpawnPolygon', { type: polygon.sides, x: mouseWorldX, y: mouseWorldY });
                    return;
                }
            }
            
            // Handle polygon spawning - 9 for all types
            if (cheatPanelActive && e.key === '9') {
                const allTypes = [3, 4, 5, 6, 8, 10, 12, 13, 14, 15, 16];
                console.log('[POLYGON SPAWN] Spawning all types');
                allTypes.forEach((type, index) => {
                    const offsetX = (index % 4) * 30 - 45;
                    const offsetY = Math.floor(index / 4) * 30 - 30;
                    socket.emit('cheatSpawnPolygon', { type, x: mouseWorldX + offsetX, y: mouseWorldY + offsetY });
                });
                return;
            }
            
            // Close admin panel with Escape (no shift required)
            if (cheatPanelActive && e.key === 'Escape') {
                cheatPanelActive = false;
                document.getElementById('cheatPanel').style.display = 'none';
                console.log('Cheat panel deactivated');
                return;
            }
            
            // Toggle health bars with 'n' key (only in game)
            if (playerId && !chatFocused && (e.key === 'n' || e.key === 'N')) {
                showAllHealthBars = !showAllHealthBars;
                console.log('Health bars:', showAllHealthBars ? 'ON' : 'OFF');
            }
            
            // Movement and game controls - only work when in game
            if (!playerId) return;
            
            if (!chatFocused && (e.key === 'w' || e.key === 'W')) {
                input.moving.up = true;
                hasMovedOrShot = true;
                hideHelpIfTimeout();
            }
            if (!chatFocused && (e.key === 's' || e.key === 'S')) {
                input.moving.down = true;
                hasMovedOrShot = true;
                hideHelpIfTimeout();
            }
            if (!chatFocused && (e.key === 'a' || e.key === 'A')) {
                input.moving.left = true;
                hasMovedOrShot = true;
                hideHelpIfTimeout();
            }
            if (!chatFocused && (e.key === 'd' || e.key === 'D')) {
                input.moving.right = true;
                hasMovedOrShot = true;
                hideHelpIfTimeout();
            }
            if (!chatFocused && (e.key === 'e' || e.key === 'E')) {
                if (!keysPressed['e']) {
                    keysPressed['e'] = true;
                    autoFire = !autoFire;
                    // When turning autofire off, also stop shooting unless mouse is held
                    if (!autoFire && !mouseDown) {
                        input.shooting = false;
                    }
                    updateControlHighlights();
                }
            }
            if (!chatFocused && (e.key === 'i' || e.key === 'I')) {
                if (!keysPressed['i']) {
                    keysPressed['i'] = true;
                    upgradeMenuVisible = !upgradeMenuVisible;
                    updateUIVisibility();
                }
            }
            if (!chatFocused && (e.key === 'h' || e.key === 'H')) {
                showingHelp = true;
                document.getElementById('controlsHelp').classList.remove('hidden');
                updateControlHighlights();
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'w' || e.key === 'W') input.moving.up = false;
            if (e.key === 's' || e.key === 'S') input.moving.down = false;
            if (e.key === 'a' || e.key === 'A') input.moving.left = false;
            if (e.key === 'd' || e.key === 'D') input.moving.right = false;
            if (e.key === 'e' || e.key === 'E') keysPressed['e'] = false;
            if (e.key === 'i' || e.key === 'I') keysPressed['i'] = false;
            if (e.key === 'h' || e.key === 'H') {
                showingHelp = false;
                if (hasMovedOrShot) {
                    document.getElementById('controlsHelp').classList.add('hidden');
                }
                updateControlHighlights();
            }
        });

        // Chat system
        let chatFocused = false;
        const chatInputBox = document.getElementById('chatInputBox');
        const chatMessages = document.getElementById('chatMessages');
        const maxChatMessages = 20;

        // Focus chat on Enter or click
        chatInputBox.addEventListener('click', () => {
            chatFocused = true;
        });

        chatInputBox.addEventListener('focus', () => {
            chatFocused = true;
        });

        chatInputBox.addEventListener('blur', () => {
            chatFocused = false;
        });

        // Handle Enter key for chat
        chatInputBox.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const message = chatInputBox.value.trim();
                if (message.length > 0) {
                    // Send chat message to server
                    socket.emit('chatMessage', message);
                    chatInputBox.value = '';
                }
                chatInputBox.blur();
                chatFocused = false;
            } else if (e.key === 'Escape') {
                chatInputBox.blur();
                chatFocused = false;
            }
        });

        // Listen for Enter key to focus chat (when not already focused)
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !chatFocused && playerId) {
                e.preventDefault();
                chatInputBox.focus();
                chatFocused = true;
            }
        });

        // Receive chat messages from server
        socket.on('chatMessage', (data) => {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';
            messageDiv.textContent = `${data.name}: ${data.message}`;
            chatMessages.appendChild(messageDiv);
            
            // Remove old messages
            while (chatMessages.children.length > maxChatMessages) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
            
            // Auto-scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
        });

        let mouseDownOnCanvas = false;

        canvas.addEventListener('mousedown', () => {
            mouseDownOnCanvas = true;
            mouseDown = true;
            input.shooting = true;
            hasMovedOrShot = true;
            hideHelpIfTimeout();
            updateControlHighlights();
        });

        canvas.addEventListener('mouseup', () => {
            // Only register as a click if mousedown also happened on canvas
            if (mouseDownOnCanvas) {
                mouseDown = false;
                input.shooting = false;
            }
            mouseDownOnCanvas = false;
            updateControlHighlights();
        });

        // Handle mouseup outside canvas
        document.addEventListener('mouseup', () => {
            if (mouseDownOnCanvas) {
                mouseDown = false;
                input.shooting = false;
                mouseDownOnCanvas = false;
                updateControlHighlights();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            lastMouseScreenX = e.clientX;
            lastMouseScreenY = e.clientY;
            const world = screenToWorld(e.clientX, e.clientY);
            mouseWorldX = world.x;
            mouseWorldY = world.y;
        });

        // Helper functions for UI management
        function hideHelpIfTimeout() {
            if (helpTimeout) {
                clearTimeout(helpTimeout);
                helpTimeout = null;
            }
            if (hasMovedOrShot && !showingHelp) {
                document.getElementById('controlsHelp').classList.add('hidden');
            }
        }

        function updateUIVisibility() {
            const upgradeMenu = document.getElementById('upgradeMenu');
            const leaderboard = document.getElementById('leaderboard');
            
            if (upgradeMenuVisible) {
                upgradeMenu.classList.add('visible');
                leaderboard.classList.add('hidden');
            } else {
                upgradeMenu.classList.remove('visible');
                leaderboard.classList.remove('hidden');
            }
        }

        function updateControlHighlights() {
            // WASD highlighting
            const wasdControl = document.getElementById('controlWASD');
            if (input.moving.up || input.moving.down || input.moving.left || input.moving.right) {
                wasdControl.classList.add('active');
            } else {
                wasdControl.classList.remove('active');
            }

            // Mouse aim highlighting
            const mouseControl = document.getElementById('controlMouse');
            mouseControl.classList.remove('active'); // Always off since it's passive

            // Click to shoot highlighting
            const clickControl = document.getElementById('controlClick');
            if (input.shooting) {
                clickControl.classList.add('active');
            } else {
                clickControl.classList.remove('active');
            }

            // E for auto-fire highlighting
            const eControl = document.getElementById('controlE');
            if (autoFire) {
                eControl.classList.add('active');
            } else {
                eControl.classList.remove('active');
            }

            // I for upgrades highlighting
            const iControl = document.getElementById('controlI');
            if (upgradeMenuVisible) {
                iControl.classList.add('active');
            } else {
                iControl.classList.remove('active');
            }

            // H for help highlighting
            const hControl = document.getElementById('controlH');
            if (showingHelp) {
                hControl.classList.add('active');
            } else {
                hControl.classList.remove('active');
            }
        }

        // Socket events
        socket.on('playerJoined', (data) => {
            playerId = data.id;
            tankTypes = data.tankTypes;
            tankUpgrades = data.tankUpgrades;
            setupUpgradeMenu();
            console.log('Player joined with ID:', playerId);
            console.log('Tank types loaded:', Object.keys(tankTypes).length);
            console.log('Tank upgrades loaded:', Object.keys(tankUpgrades).length);
        });

        socket.on('gameState', (state) => {
            gameState = state;
            
            // Auto-show upgrade menu on level up if player has upgrade points
            if (playerId) {
                const player = state.players.find(p => p.id === playerId);
                if (player) {
                    // Track which tanks the player has used
                    usedTanks.add(player.tankType);
                    
                    if (player.level > lastKnownLevel && player.upgradePoints > 0) {
                        upgradeMenuVisible = true;
                        updateUIVisibility();
                    }
                    lastKnownLevel = player.level;
                }
            }
            
            updateHUD();
            updateLeaderboard();
            
            // Start auto-hide timer for controls help on first game state
            if (!hasMovedOrShot && !helpTimeout) {
                helpTimeout = setTimeout(() => {
                    if (!hasMovedOrShot && !showingHelp) {
                        document.getElementById('controlsHelp').classList.add('hidden');
                    }
                }, 6000);
            }
        });

        // Handle admin verification response
        socket.on('adminVerified', (verified) => {
            if (verified) {
                cheatPanelActive = true;
                document.getElementById('cheatPanel').style.display = 'block';
                console.log('Admin access granted!');
            } else {
                console.log('Admin access denied - incorrect code');
            }
        });

        // Handle player death
        // Handle player death
        socket.on('playerDied', (data) => {
            // Return to main menu on death
            playerId = null;
            gameState = null;
            
            // Tell server to remove this player
            socket.emit('playerLeaveGame');
            
            const deathScreen = document.getElementById('deathScreen');
            const killedByList = document.getElementById('killedByList');
            
            killedByList.innerHTML = '<div class="killed-by">Killed by:</div>';
            
            if (data.killedBy.length === 0) {
                killedByList.innerHTML += '<div class="killer-name">Unknown</div>';
            } else {
                data.killedBy.forEach(killer => {
                    if (killer.type === 'player') {
                        const tankConfig = (tankTypes && tankTypes[killer.tankType]) || {name: 'Basic'};
                        killedByList.innerHTML += `<div class="killer-name">${killer.name} (${tankConfig.name})</div>`;
                    } else if (killer.type === 'polygon') {
                        killedByList.innerHTML += `<div class="killer-name">${killer.name}</div>`;
                    }
                });
            }
            
            deathScreen.classList.add('visible');
            
            // Auto-hide and show menu after 3 seconds
            setTimeout(() => {
                deathScreen.classList.remove('visible');
                document.getElementById('startMenu').classList.remove('hidden');
                document.getElementById('hud').classList.remove('visible');
            }, 3000);
        });

        // Handle AFK kick
        socket.on('afkKick', (data) => {
            playerId = null;
            gameState = null;
            
            const deathScreen = document.getElementById('deathScreen');
            const killedByList = document.getElementById('killedByList');
            
            killedByList.innerHTML = `
                <div class="death-title">KICKED</div>
                <div class="killed-by" style="font-size: 18px; margin-top: 10px;">${data.reason}</div>
            `;
            
            deathScreen.classList.add('visible');
            
            // Auto-hide and show menu after 3 seconds
            setTimeout(() => {
                deathScreen.classList.remove('visible');
                const startMenu = document.getElementById('startMenu');
                if (startMenu) {
                    startMenu.classList.remove('hidden');
                }
            }, 3000);
        });

        // Send input to server
        setInterval(() => {
            if (playerId) {
                input.mouseX = mouseWorldX;
                input.mouseY = mouseWorldY;
                input.shooting = input.shooting || autoFire;
                socket.emit('playerInput', input);
            }
        }, 1000 / 60);

        // Setup button event listeners
        document.getElementById('viewUpgradeTreeBtn').addEventListener('click', () => {
            showUpgradeTree(false);
        });
        
        document.getElementById('viewUpgradeTreeCheat').addEventListener('click', () => {
            showUpgradeTree(true);
        });
        
        document.getElementById('closeUpgradeTreeBtn').addEventListener('click', () => {
            document.getElementById('upgradeTreeModal').style.display = 'none';
        });

        // XP amount control buttons
        let teleportMode = 'all'; // 'all', 'others', or 'you'

        document.getElementById('decreaseXP').addEventListener('click', () => {
            xpAmount = Math.max(1, Math.floor(xpAmount / 2));
            document.getElementById('xpAmount').textContent = xpAmount;
        });

        document.getElementById('increaseXP').addEventListener('click', () => {
            xpAmount = Math.min(1000000, xpAmount * 2);
            document.getElementById('xpAmount').textContent = xpAmount;
        });

        // Teleport mode buttons
        function updateTeleportButtons() {
            document.getElementById('tpModeAll').style.background = teleportMode === 'all' ? '#44ff44' : '#666';
            document.getElementById('tpModeOthers').style.background = teleportMode === 'others' ? '#44ff44' : '#666';
            document.getElementById('tpModeYou').style.background = teleportMode === 'you' ? '#44ff44' : '#666';
        }

        document.getElementById('tpModeAll').addEventListener('click', () => {
            teleportMode = 'all';
            updateTeleportButtons();
        });

        document.getElementById('tpModeOthers').addEventListener('click', () => {
            teleportMode = 'others';
            updateTeleportButtons();
        });

        document.getElementById('tpModeYou').addEventListener('click', () => {
            teleportMode = 'you';
            updateTeleportButtons();
        });

        // Polygon selection buttons
        function updatePolygonDisplay() {
            const polygon = polygonTypes[selectedPolygonIndex];
            document.getElementById('polygonDisplay').textContent = `${polygon.name} (Tier ${polygon.tier})`;
        }

        document.getElementById('prevPolygon').addEventListener('click', () => {
            selectedPolygonIndex = (selectedPolygonIndex - 1 + polygonTypes.length) % polygonTypes.length;
            updatePolygonDisplay();
        });

        document.getElementById('nextPolygon').addEventListener('click', () => {
            selectedPolygonIndex = (selectedPolygonIndex + 1) % polygonTypes.length;
            updatePolygonDisplay();
        });


        // Setup upgrade menu
        function setupUpgradeMenu() {
            const statUpgrades = document.getElementById('statUpgrades');
            
            // Clear existing stat upgrades to prevent duplicates
            statUpgrades.innerHTML = '';
            
            const stats = [
                'healthRegen', 'maxHealth', 'bodyDamage', 'bulletSpeed',
                'bulletPenetration', 'bulletDamage', 'reload', 'movementSpeed'
            ];
            
            const statNames = {
                healthRegen: 'Health Regen',
                maxHealth: 'Max Health',
                bodyDamage: 'Body Damage',
                bulletSpeed: 'Bullet Speed',
                bulletPenetration: 'Bullet Health',
                bulletDamage: 'Bullet Damage',
                reload: 'Reload',
                movementSpeed: 'Movement Speed'
            };

            stats.forEach(stat => {
                const div = document.createElement('div');
                div.className = 'stat-upgrade';
                div.dataset.stat = stat;
                div.innerHTML = `
                    <span>${statNames[stat]}</span>
                    <div class="stat-bars">
                        ${Array(7).fill('<div class="stat-bar"></div>').join('')}
                    </div>
                `;
                div.addEventListener('click', () => {
                    socket.emit('upgradeStat', stat);
                });
                statUpgrades.appendChild(div);
            });
        }

        function updateUpgradeMenu(player) {
            if (!player) return;

            // Update upgrade points display
            const upgradePointsDisplay = document.getElementById('upgradePointsDisplay');
            if (upgradePointsDisplay && player.upgradePoints !== undefined) {
                upgradePointsDisplay.textContent = `Upgrade Points: ${player.upgradePoints}`;
            }

            // Update stat bars
            const stats = [
                'healthRegen', 'maxHealth', 'bodyDamage', 'bulletSpeed',
                'bulletPenetration', 'bulletDamage', 'reload', 'movementSpeed'
            ];

            stats.forEach(stat => {
                const div = document.querySelector(`[data-stat="${stat}"]`);
                if (div) {
                    const bars = div.querySelectorAll('.stat-bar');
                    const level = player.stats ? player.stats[stat] || 0 : 0;
                    
                    // Show up to current level (max 7)
                    bars.forEach((bar, i) => {
                        bar.classList.toggle('filled', i < level);
                    });
                    
                    // Disable if no points available or already at max level
                    div.classList.toggle('maxed', player.upgradePoints <= 0 || level >= 7);
                }
            });

            // Update tank upgrades - only rebuild if tank type changed
            const tankUpgradeSection = document.getElementById('tankUpgradeSection');
            const tankUpgradesDiv = document.getElementById('tankUpgrades');
            const viewUpgradeTreeBtn = document.getElementById('viewUpgradeTreeBtn');
            
            if (tankTypes && player && player.tankType) {
                const currentTank = tankTypes[player.tankType];
                
                // Get available upgrades from tankUpgrades JSON
                const availableUpgrades = tankUpgrades && tankUpgrades[player.tankType] ? tankUpgrades[player.tankType] : [];
                
                if (availableUpgrades && availableUpgrades.length > 0) {
                    tankUpgradeSection.style.display = 'block';
                    viewUpgradeTreeBtn.style.display = 'none'; // Hide button when tank upgrades are shown
                    
                    // Only rebuild if tank type changed
                    if (tankUpgradesDiv.dataset.currentTank !== player.tankType) {
                        tankUpgradesDiv.innerHTML = '';
                        tankUpgradesDiv.dataset.currentTank = player.tankType;
                        
                        availableUpgrades.forEach(tankType => {
                            const tankConfig = tankTypes[tankType];
                            
                            const div = document.createElement('div');
                            div.className = 'tank-upgrade';
                            div.dataset.tankType = tankType;
                            div.dataset.requiredLevel = tankConfig.level;
                            div.innerHTML = `
                                <div class="tank-name">${tankConfig.name}</div>
                                <div class="tank-level">Level ${tankConfig.level}</div>
                            `;
                            
                            div.addEventListener('click', () => {
                                // Get current player state at click time
                                if (!gameState || !playerId) return;
                                const currentPlayer = gameState.players.find(p => p.id === playerId);
                                if (!currentPlayer) return;
                                
                                const canUpgrade = currentPlayer.level >= tankConfig.level;
                                if (canUpgrade) {
                                    console.log('Upgrading to:', tankType);
                                    socket.emit('upgradeTank', tankType);
                                }
                            });
                            
                            tankUpgradesDiv.appendChild(div);
                        });
                    }
                    
                    // Update locked/unlocked state based on current level
                    tankUpgradesDiv.querySelectorAll('.tank-upgrade').forEach(div => {
                        const requiredLevel = parseInt(div.dataset.requiredLevel);
                        const canUpgrade = player.level >= requiredLevel;
                        div.classList.toggle('locked', !canUpgrade);
                    });
                } else {
                    tankUpgradeSection.style.display = 'none';
                    viewUpgradeTreeBtn.style.display = 'block'; // Show button when tank upgrades are hidden
                }
            }
        }

        // Update HUD
        function updateHUD() {
            if (!gameState || !playerId) return;

            const player = gameState.players.find(p => p.id === playerId);
            if (!player) return;

            document.getElementById('score').textContent = Math.floor(player.score);
            document.getElementById('level').textContent = player.level;

            const healthPercent = (player.health / player.maxHealth) * 100;
            document.getElementById('healthFill').style.width = healthPercent + '%';

            const requiredXP = player.level * 100;
            const xpPercent = (player.xp / requiredXP) * 100;
            document.getElementById('xpFill').style.width = xpPercent + '%';

            // Only update upgrade menu if it's currently visible
            if (upgradeMenuVisible) {
                updateUpgradeMenu(player);
            }

            // Update camera FOV based on tank and size
            if (tankTypes && player && player.tankType) {
                const tankConfig = tankTypes[player.tankType];
                const baseFov = tankConfig.fov || 1;
                // Base zoom is higher (more zoomed in) - 1.3x default zoom
                // Player size affects FOV: larger = extra wider view (more than linear)
                const sizeFactor = 1 + (player.size - 20) / 60; // Grows faster with size (was /100)
                setCameraSize((baseFov * sizeFactor) / 1.3); // Divide by 1.3 for more zoom
            }
        }

        // Update leaderboard
        function updateLeaderboard() {
            if (!gameState) return;

            const sorted = [...gameState.players].sort((a, b) => b.score - a.score);
            const list = document.getElementById('leaderboardList');
            
            list.innerHTML = sorted.slice(0, 10).map((player, i) => {
                return `<div class="leaderboard-entry">${i + 1}. ${player.name} - ${Math.floor(player.score)}</div>`;
            }).join('');
        }

        // Upgrade tree visualization
        let usedTanks = new Set(['BASIC']); // Track which tanks the player has used
        let treeViewOffset = { x: 0, y: 0 }; // For panning
        let treeViewZoom = 1; // For zooming
        let treeDragging = false;
        let treeDragStart = { x: 0, y: 0 };
        let hoveredTank = null; // Track which tank is being hovered
        let highlightedPaths = []; // Paths to highlight
        let currentPathIndex = 0; // For alternating between multiple paths
        let pathAlternateInterval = null; // Interval for path alternation
        
        function showUpgradeTree(allowMorphing = false) {
            const modal = document.getElementById('upgradeTreeModal');
            const canvas = document.getElementById('upgradeTreeCanvas');
            modal.style.display = 'block';
            
            // Build tree structure (show hidden tanks when morphing is allowed)
            const treeData = buildTreeStructure(allowMorphing);
            
            // Calculate canvas size based on viewport
            const width = window.innerWidth - 100;
            const height = window.innerHeight - 100;
            canvas.width = width;
            canvas.height = height;
            
            treeViewOffset = { x: width / 2, y: 50 }; // Center horizontally, near top
            treeViewZoom = 1; // Reset zoom
            
            const treeCtx = canvas.getContext('2d');
            
            // Draw the tree
            drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
            
            // Add drag functionality
            setupTreeDrag(canvas, treeCtx, treeData, allowMorphing);
            
            // Add zoom button handlers
            setupTreeZoom(canvas, treeCtx, treeData, allowMorphing);
        }
        
        function setupTreeDrag(canvas, treeCtx, treeData, allowMorphing) {
            canvas.onmousedown = (e) => {
                if (e.button === 0) { // Left click for dragging
                    treeDragging = true;
                    treeDragStart = { x: e.clientX - treeViewOffset.x, y: e.clientY - treeViewOffset.y };
                }
            };
            
            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left - treeViewOffset.x) / treeViewZoom;
                const mouseY = (e.clientY - rect.top - treeViewOffset.y) / treeViewZoom;
                
                if (treeDragging) {
                    treeViewOffset.x = e.clientX - treeDragStart.x;
                    treeViewOffset.y = e.clientY - treeDragStart.y;
                    drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
                } else {
                    // Check for hover
                    const { nodePositions } = buildTreeLayout(treeData);
                    let newHoveredTank = null;
                    
                    for (const tankKey in nodePositions) {
                        const pos = nodePositions[tankKey];
                        const dist = Math.sqrt((mouseX - pos.x) ** 2 + (mouseY - pos.y) ** 2);
                        
                        if (dist < 30) {
                            newHoveredTank = tankKey;
                            break;
                        }
                    }
                    
                    // If hover changed, update paths
                    if (newHoveredTank !== hoveredTank) {
                        hoveredTank = newHoveredTank;
                        
                        if (hoveredTank) {
                            // Find all paths to this tank
                            highlightedPaths = findAllPaths('BASIC', hoveredTank, treeData.upgrades);
                            currentPathIndex = 0;
                            
                            // Start alternating if multiple paths
                            if (pathAlternateInterval) clearInterval(pathAlternateInterval);
                            if (highlightedPaths.length > 1) {
                                pathAlternateInterval = setInterval(() => {
                                    currentPathIndex = (currentPathIndex + 1) % highlightedPaths.length;
                                    drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
                                }, 1000);
                            }
                        } else {
                            highlightedPaths = [];
                            if (pathAlternateInterval) {
                                clearInterval(pathAlternateInterval);
                                pathAlternateInterval = null;
                            }
                        }
                        
                        drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
                    }
                }
            };
            
            canvas.onmouseup = () => {
                treeDragging = false;
            };
            
            canvas.onmouseleave = () => {
                treeDragging = false;
            };
            
            // Right-click for morphing
            if (allowMorphing) {
                canvas.oncontextmenu = (e) => {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const clickX = (e.clientX - rect.left - treeViewOffset.x) / treeViewZoom;
                    const clickY = (e.clientY - rect.top - treeViewOffset.y) / treeViewZoom;
                    
                    const { nodePositions } = buildTreeLayout(treeData);
                    
                    for (const tankKey in nodePositions) {
                        const pos = nodePositions[tankKey];
                        const dist = Math.sqrt((clickX - pos.x) ** 2 + (clickY - pos.y) ** 2);
                        
                        if (dist < 30) {
                            // In cheat mode, use cheatMorphTank instead of upgradeTank
                            socket.emit('cheatMorphTank', tankKey);
                            usedTanks.add(tankKey);
                            drawUpgradeTree(treeCtx, treeData, true, canvas);
                            break;
                        }
                    }
                };
            }
        }
        
        function setupTreeZoom(canvas, treeCtx, treeData, allowMorphing) {
            // Zoom in button
            document.getElementById('zoomInTreeBtn').onclick = () => {
                treeViewZoom *= 1.2;
                drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
            };
            
            // Zoom out button
            document.getElementById('zoomOutTreeBtn').onclick = () => {
                treeViewZoom /= 1.2;
                drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
            };
            
            // Reset button
            document.getElementById('resetTreeBtn').onclick = () => {
                treeViewOffset = { x: canvas.width / 2, y: 50 };
                treeViewZoom = 1;
                drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
            };
            
            // Mouse wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                treeViewZoom *= zoomFactor;
                drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas);
            }, { passive: false });
        }
        
        // Find all upgrade paths from start to end tank
        function findAllPaths(start, end, upgrades) {
            if (start === end) return [[start]];
            
            const allPaths = [];
            
            function dfs(current, target, path, visited) {
                if (current === target) {
                    allPaths.push([...path]);
                    return;
                }
                
                const nextTanks = upgrades[current] || [];
                for (const next of nextTanks) {
                    if (!visited.has(next)) {
                        visited.add(next);
                        path.push(next);
                        dfs(next, target, path, visited);
                        path.pop();
                        visited.delete(next);
                    }
                }
            }
            
            dfs(start, end, [start], new Set([start]));
            return allPaths;
        }
        
        function buildTreeStructure(showHiddenTanks = false) {
            if (!tankUpgrades || !tankTypes) return null;
            
            const levels = {};
            
            // Group tanks by level (optionally include hidden tanks)
            for (const tankKey in tankTypes) {
                const tank = tankTypes[tankKey];
                if (!showHiddenTanks && tank.hideFromTree) continue; // Skip hidden tanks unless requested
                const level = tank.level;
                if (!levels[level]) levels[level] = [];
                levels[level].push(tankKey);
            }
            
            return { levels, upgrades: tankUpgrades };
        }
        
        function buildTreeLayout(treeData) {
            const { levels } = treeData;
            const levelKeys = Object.keys(levels).map(Number).sort((a, b) => a - b);
            
            const nodePositions = {};
            
            // Calculate positions for each tank
            levelKeys.forEach((level, levelIndex) => {
                const tanksAtLevel = levels[level];
                const totalWidth = tanksAtLevel.length * 150;
                const levelY = 50 + levelIndex * 200;
                
                tanksAtLevel.forEach((tankKey, tankIndex) => {
                    const x = 50 + tankIndex * 150 - totalWidth / 2;
                    const y = levelY;
                    nodePositions[tankKey] = { x, y };
                });
            });
            
            return { nodePositions };
        }
        
        function drawUpgradeTree(treeCtx, treeData, allowMorphing, canvas) {
            if (!treeData || !tankTypes) return;
            
            const { upgrades } = treeData;
            const { nodePositions } = buildTreeLayout(treeData);
            
            // Clear canvas
            treeCtx.fillStyle = '#2a2a2a';
            treeCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            treeCtx.save();
            treeCtx.translate(treeViewOffset.x, treeViewOffset.y);
            treeCtx.scale(treeViewZoom, treeViewZoom); // Apply zoom
            
            // Draw connections first
            treeCtx.lineWidth = 3 / treeViewZoom; // Adjust line width for zoom
            
            // Get current path to highlight
            const currentPath = highlightedPaths.length > 0 ? highlightedPaths[currentPathIndex] : [];
            const pathSet = new Set();
            for (let i = 0; i < currentPath.length - 1; i++) {
                pathSet.add(`${currentPath[i]}->${currentPath[i + 1]}`);
            }
            
            for (const fromTank in upgrades) {
                const toTanks = upgrades[fromTank];
                if (!nodePositions[fromTank]) continue;
                
                toTanks.forEach(toTank => {
                    if (!nodePositions[toTank]) return;
                    
                    const isInPath = pathSet.has(`${fromTank}->${toTank}`);
                    
                    // Check if both ends have been used
                    const fromUsed = usedTanks.has(fromTank);
                    const toUsed = usedTanks.has(toTank);
                    
                    if (isInPath) {
                        // Glowing effect for highlighted path
                        treeCtx.strokeStyle = '#ffff00';
                        treeCtx.lineWidth = 6 / treeViewZoom;
                        treeCtx.shadowBlur = 15;
                        treeCtx.shadowColor = '#ffff00';
                    } else if (fromUsed && toUsed) {
                        treeCtx.strokeStyle = '#aaa'; // Brighter
                        treeCtx.lineWidth = 3 / treeViewZoom;
                        treeCtx.shadowBlur = 0;
                    } else {
                        treeCtx.strokeStyle = '#555'; // Normal
                        treeCtx.lineWidth = 3 / treeViewZoom;
                        treeCtx.shadowBlur = 0;
                    }
                    
                    treeCtx.beginPath();
                    treeCtx.moveTo(nodePositions[fromTank].x, nodePositions[fromTank].y + 30);
                    treeCtx.lineTo(nodePositions[toTank].x, nodePositions[toTank].y - 30);
                    treeCtx.stroke();
                });
            }
            
            // Reset shadow
            treeCtx.shadowBlur = 0;
            
            // Draw nodes
            for (const tankKey in nodePositions) {
                const pos = nodePositions[tankKey];
                const tank = tankTypes[tankKey];
                const isUsed = usedTanks.has(tankKey);
                
                drawTankPreview(treeCtx, tank, pos.x, pos.y, isUsed);
                
                // Draw name below tank
                treeCtx.fillStyle = isUsed ? '#fff' : '#888';
                treeCtx.font = 'bold 14px Arial';
                treeCtx.textAlign = 'center';
                treeCtx.fillText(tank.name, pos.x, pos.y + 55);
            }
            
            treeCtx.restore();
        }
        
        function drawTankPreview(ctx, tankConfig, x, y, isUsed) {
            ctx.save();
            ctx.translate(x, y);
            
            const scale = 0.8;
            const baseSize = 30 * scale;
            
            // Draw guns first (layer 0)
            if (tankConfig.guns) {
                tankConfig.guns.forEach(gun => {
                    const gunAngle = (gun.angle || 0) * Math.PI / 180;
                    const offsetY = (gun.offsetY || 0) * scale;
                    const offsetX = (gun.offsetX || 0) * scale;
                    
                    ctx.save();
                    ctx.rotate(gunAngle);
                    ctx.translate(offsetX, offsetY);
                    
                    if (gun.type === 'normal') {
                        const gunLength = (gun.length || 1) * 20 * scale;
                        const gunWidth = (gun.size || 1) * 20 * scale;
                        
                        ctx.fillStyle = '#999';
                        ctx.fillRect(baseSize - 5 * scale, -gunWidth / 2, gunLength, gunWidth);
                        ctx.strokeStyle = '#404040';
                        ctx.lineWidth = 1.5;
                        ctx.strokeRect(baseSize - 5 * scale, -gunWidth / 2, gunLength, gunWidth);
                    } else if (gun.type === 'trap') {
                        const trapSize = 15 * scale;
                        ctx.fillStyle = '#999';
                        ctx.fillRect(baseSize - 3 * scale, -trapSize / 2, trapSize, trapSize);
                        ctx.strokeStyle = '#404040';
                        ctx.lineWidth = 1.5;
                        ctx.strokeRect(baseSize - 3 * scale, -trapSize / 2, trapSize, trapSize);
                    } else if (gun.type === 'minion') {
                        // Draw thin trapezoid for minion spawner - wide side facing out
                        const length = 25 * scale;
                        const baseWidth = 8 * scale; // Narrow end (at tank)
                        const tipWidth = 18 * scale; // Wide end (facing out)
                        const baseX = baseSize - 5 * scale;
                        
                        ctx.fillStyle = '#999';
                        ctx.strokeStyle = '#404040';
                        ctx.lineWidth = 1.5;
                        
                        ctx.beginPath();
                        ctx.moveTo(baseX, -baseWidth / 2); // Back top corner (narrow base)
                        ctx.lineTo(baseX + length, -tipWidth / 2); // Front top corner (wide tip)
                        ctx.lineTo(baseX + length, tipWidth / 2); // Front bottom corner (wide tip)
                        ctx.lineTo(baseX, baseWidth / 2); // Back bottom corner (narrow base)
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                });
            }
            
            // Draw base shape
            if (tankConfig.baseShape === 'blade' || tankConfig.baseShape === 'blade_twin') {
                // Draw blade/smasher shape with grey polygon base
                const bladeShape = tankConfig.bladeShape || 'square';
                const bladeCount = tankConfig.bladeCount || 1;
                const bladeSize = tankConfig.bladeSize || 1.35;
                
                let baseSides = 4; // Default square
                if (bladeShape === 'triangle') baseSides = 3;
                else if (bladeShape === 'square') baseSides = 4;
                else if (bladeShape === 'pentagon') baseSides = 5;
                else if (bladeShape === 'hexagon') baseSides = 6;
                else if (bladeShape === 'octagon') baseSides = 8;
                
                // Draw multiple blade layers
                for (let layer = 0; layer < bladeCount; layer++) {
                    const layerRotation = (layer / bladeCount) * (Math.PI / baseSides);
                    const layerSize = baseSize * bladeSize * (1 - layer * 0.15);
                    
                    ctx.save();
                    ctx.rotate(layerRotation);
                    
                    ctx.fillStyle = '#999';
                    ctx.beginPath();
                    for (let i = 0; i < baseSides; i++) {
                        const angle = (i / baseSides) * Math.PI * 2 - Math.PI / 2;
                        const x = Math.cos(angle) * layerSize;
                        const y = Math.sin(angle) * layerSize;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#404040';
                    ctx.lineWidth = 2.5;
                    ctx.stroke();
                    
                    ctx.restore();
                }
                
                // Draw outer colored circles (baseLayers support)
                const baseLayers = tankConfig.baseLayers;
                const circleColors = isUsed ? ['#00B2E1', '#0099C9'] : ['#444', '#333'];
                
                if (Array.isArray(baseLayers)) {
                    // Custom layer configuration for preview
                    baseLayers.forEach((layer, i) => {
                        const layerSize = baseSize * (layer.size || 1.0);
                        const layerColor = layer.color || circleColors[i % circleColors.length];
                        const sides = layer.sides || 0;
                        const stretch = layer.stretch || { x: 1, y: 1 };
                        
                        ctx.save();
                        ctx.scale(stretch.x, stretch.y);
                        ctx.fillStyle = layerColor;
                        
                        if (sides === 0) {
                            ctx.beginPath();
                            ctx.arc(0, 0, layerSize, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            ctx.beginPath();
                            for (let j = 0; j < sides; j++) {
                                const angle = (j / sides) * Math.PI * 2 - Math.PI / 2;
                                const x = Math.cos(angle) * layerSize;
                                const y = Math.sin(angle) * layerSize;
                                if (j === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        ctx.restore();
                    });
                } else {
                    // Default circular layers
                    const circleSizes = [baseSize * 1.1, baseSize * 0.7];
                    circleColors.forEach((color, i) => {
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(0, 0, circleSizes[i], 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
            } else {
                // Draw circle base
                ctx.fillStyle = isUsed ? '#00a2ff' : '#444';
                ctx.beginPath();
                ctx.arc(0, 0, baseSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = isUsed ? '#fff' : '#666';
                ctx.lineWidth = 2.5;
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // Helper function to render a base block
        function renderBaseBlock(baseBlock, player, size, sizeMultiplier) {
            ctx.save();
            ctx.translate(baseBlock.x * camera.zoom * sizeMultiplier, baseBlock.y * camera.zoom * sizeMultiplier);
            ctx.rotate((baseBlock.rotation || 0) * Math.PI / 180);
            
            const blockColor = baseBlock.color || (player.id === playerId ? '#00B2E1' : '#F14E54');
            ctx.fillStyle = blockColor;
            ctx.strokeStyle = darkenColor(blockColor, 0.3);
            ctx.lineWidth = 3 * camera.zoom;
            
            if (baseBlock.shape === 0) {
                // Circle
                const radius = (baseBlock.size + (baseBlock.width || 0)) * camera.zoom * sizeMultiplier;
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            } else if (baseBlock.shape === 4 && (baseBlock.width || baseBlock.height)) {
                // Rectangle
                const totalWidth = (baseBlock.size + (baseBlock.width || 0)) * camera.zoom * sizeMultiplier;
                const totalHeight = (baseBlock.size + (baseBlock.height || 0)) * camera.zoom * sizeMultiplier;
                ctx.beginPath();
                ctx.rect(-totalWidth/2, -totalHeight/2, totalWidth, totalHeight);
                ctx.fill();
                ctx.stroke();
            } else {
                // Polygon
                const sides = baseBlock.shape;
                const radiusX = (baseBlock.size + (baseBlock.width || 0)) * camera.zoom * sizeMultiplier;
                const radiusY = (baseBlock.size + (baseBlock.height || 0)) * camera.zoom * sizeMultiplier;
                ctx.beginPath();
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                    const x = Math.cos(angle) * radiusX;
                    const y = Math.sin(angle) * radiusY;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        // Helper function to render a blade
        function renderBlade(blade, player, size, sizeMultiplier) {
            ctx.save();
            ctx.translate(blade.x * camera.zoom * sizeMultiplier, blade.y * camera.zoom * sizeMultiplier);
            ctx.rotate((blade.rotation || 0) * Math.PI / 180);
            
            const bladeSize = blade.size * size;
            const sides = blade.shape;
            
            ctx.fillStyle = blade.color || '#999999';
            ctx.strokeStyle = darkenColor(blade.color || '#999999', 0.3);
            ctx.lineWidth = 3 * camera.zoom;
            
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                const x = Math.cos(angle) * bladeSize;
                const y = Math.sin(angle) * bladeSize;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
        }

        function drawBullet(bullet) {
            const screen = worldToScreen(bullet.x, bullet.y);
            
            // Apply death animation: shrink and fade out with particle effect
            let size = bullet.size * camera.zoom;
            let alpha = 1;
            
            if (bullet.dying) {
                const progress = bullet.deathProgress || 0;
                // Shrink from size to 0
                size = bullet.size * camera.zoom * (1 - progress);
                // Fade from 1 to 0
                alpha = 1 - progress;
                
                // Draw explosion particles
                const particleCount = 8;
                const particleSize = 3 * camera.zoom;
                const maxDist = 15 * camera.zoom * progress;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const dist = maxDist * (0.5 + Math.random() * 0.5);
                    const px = screen.x + Math.cos(angle) * dist;
                    const py = screen.y + Math.sin(angle) * dist;
                    
                    ctx.fillStyle = '#00B2E1';
                    ctx.beginPath();
                    ctx.arc(px, py, particleSize * (1 - progress * 0.5), 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            ctx.save();
            ctx.globalAlpha = alpha;
            const bulletColor = '#00B2E1';
            ctx.fillStyle = bulletColor;
            ctx.strokeStyle = darkenColor(bulletColor, 0.3);
            ctx.lineWidth = 2 * camera.zoom;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, size, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
            
            // Draw health bar if toggle is on
            if (showAllHealthBars && bullet.health !== undefined && bullet.maxHealth !== undefined) {
                const healthPercent = bullet.health / bullet.maxHealth;
                const barWidth = size * 2;
                const barHeight = 4 * camera.zoom;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);
                
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth * healthPercent, barHeight);
                
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.strokeRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);
            }
        }

        function drawTrap(trap) {
            const screen = worldToScreen(trap.x, trap.y);
            let size = trap.size * camera.zoom;
            
            // Death animation - shrink and fade
            let alpha = 1;
            if (trap.dying) {
                const progress = trap.deathProgress || 0;
                size *= (1 - progress);
                alpha = 1 - progress;
                if (progress >= 1) return; // Don't draw if animation complete
            }

            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(screen.x, screen.y);
            ctx.rotate(trap.rotation);

            // Blue for own traps, red for enemy traps
            const isOwn = trap.owner === playerId;
            const trapColor = isOwn ? '#00B2E1' : '#FE7C6D';
            ctx.fillStyle = trapColor;
            ctx.strokeStyle = darkenColor(trapColor, 0.3);
            ctx.lineWidth = 3 * camera.zoom;

            ctx.beginPath();
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                const x = Math.cos(angle) * size;
                const y = Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore();
            
            // Draw health bar if toggle is on and not dying
            if (!trap.dying && showAllHealthBars && trap.health !== undefined && trap.maxHealth !== undefined) {
                const healthPercent = trap.health / trap.maxHealth;
                const barWidth = size * 2.5;
                const barHeight = 4 * camera.zoom;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);
                
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth * healthPercent, barHeight);
                
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.strokeRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);
            }
        }

        function drawMinion(minion) {
            const screen = worldToScreen(minion.x, minion.y);
            let size = minion.size * camera.zoom;
            
            // Death animation - shrink and fade
            let alpha = 1;
            if (minion.dying) {
                const progress = minion.deathProgress || 0;
                size *= (1 - progress);
                alpha = 1 - progress;
                if (progress >= 1) return; // Don't draw if animation complete
            }

            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(screen.x, screen.y);
            ctx.rotate(minion.rotation);

            // Draw triangle base
            const minionColor = '#00B2E1';
            ctx.fillStyle = minionColor;
            ctx.strokeStyle = darkenColor(minionColor, 0.3);
            ctx.lineWidth = 2 * camera.zoom;

            ctx.beginPath();
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2 - Math.PI / 2;
                const x = Math.cos(angle) * size;
                const y = Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
            
            // Draw health bar if toggle is on and not dying
            if (!minion.dying && showAllHealthBars && minion.health !== undefined && minion.maxHealth !== undefined) {
                const healthPercent = minion.health / minion.maxHealth;
                const barWidth = size * 2.5;
                const barHeight = 4 * camera.zoom;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);
                
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth * healthPercent, barHeight);
                
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.strokeRect(screen.x - barWidth / 2, screen.y - size - 10 * camera.zoom, barWidth, barHeight);
            }
        }

        // Helper function to check if object is in viewport
        function isInViewport(obj, size = 50) {
            const screen = worldToScreen(obj.x, obj.y);
            const margin = size * camera.zoom + 100; // Extra margin for safety
            
            return screen.x > -margin && screen.x < canvas.width + margin &&
                   screen.y > -margin && screen.y < canvas.height + margin;
        }

        // Draw minimap
        function drawMinimap() {
            const minimapCanvas = document.getElementById('minimap');
            if (!minimapCanvas || !gameState || !playerId) return;
            
            const minimapCtx = minimapCanvas.getContext('2d');
            const minimapSize = 150;
            const center = minimapSize / 2;
            const mapRadius = 3000; // Game map radius
            const minimapScale = center / mapRadius; // Scale from game units to minimap pixels
            
            // Clear minimap
            minimapCtx.clearRect(0, 0, minimapSize, minimapSize);
            
            // Draw map circle background
            minimapCtx.fillStyle = 'rgba(200, 200, 200, 0.3)';
            minimapCtx.beginPath();
            minimapCtx.arc(center, center, center - 2, 0, Math.PI * 2);
            minimapCtx.fill();
            
            // Draw map border
            minimapCtx.strokeStyle = '#404040';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.arc(center, center, center - 2, 0, Math.PI * 2);
            minimapCtx.stroke();
            
            // Find player
            const player = gameState.players.find(p => p.id === playerId);
            if (!player) return;
            
            // Draw big polygons (pentagon=30, hexagon=40, octagon=50, decagon=60, dodecagon=70)
            if (gameState.polygons) {
                gameState.polygons.forEach(polygon => {
                    if (polygon.size >= 30) { // Only show pentagons and bigger
                        const x = center + polygon.x * minimapScale;
                        const y = center + polygon.y * minimapScale;
                        
                        // Different colors for different sizes
                        if (polygon.size >= 70) {
                            minimapCtx.fillStyle = '#FF6666'; // Dodecagon - red
                        } else if (polygon.size >= 60) {
                            minimapCtx.fillStyle = '#66CCFF'; // Decagon - cyan
                        } else if (polygon.size >= 50) {
                            minimapCtx.fillStyle = '#8B66FF'; // Octagon - purple
                        } else if (polygon.size >= 40) {
                            minimapCtx.fillStyle = '#FF6EC7'; // Hexagon - pink
                        } else {
                            minimapCtx.fillStyle = '#768CFF'; // Pentagon - blue
                        }
                        
                        minimapCtx.beginPath();
                        minimapCtx.arc(x, y, 3, 0, Math.PI * 2);
                        minimapCtx.fill();
                    }
                });
            }
            
            // Draw player arrow pointing at cursor
            const playerX = center + player.x * minimapScale;
            const playerY = center + player.y * minimapScale;
            
            minimapCtx.save();
            minimapCtx.translate(playerX, playerY);
            minimapCtx.rotate(player.rotation);
            
            // Draw arrow
            minimapCtx.fillStyle = '#00ff00'; // Green arrow
            minimapCtx.strokeStyle = '#004400';
            minimapCtx.lineWidth = 1;
            minimapCtx.beginPath();
            minimapCtx.moveTo(8, 0); // Point
            minimapCtx.lineTo(-4, -4); // Top back
            minimapCtx.lineTo(-2, 0); // Middle back
            minimapCtx.lineTo(-4, 4); // Bottom back
            minimapCtx.closePath();
            minimapCtx.fill();
            minimapCtx.stroke();
            
            minimapCtx.restore();
        }

        // Main render loop
        function render() {
            // Update mouse world position based on current camera (fixes stuck aim when camera moves)
            const world = screenToWorld(lastMouseScreenX, lastMouseScreenY);
            mouseWorldX = world.x;
            mouseWorldY = world.y;
            
            // Prevent text blur - use integer translation
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            
            // Clear with background color
            ctx.fillStyle = '#cdcdcd';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!gameState) {
                // Draw menu background (view of map center)
                camera.x = 0;
                camera.y = 0;
                camera.zoom = 0.5;

                ctx.restore();
                requestAnimationFrame(render);
                return;
            }

            // If player hasn't joined yet, show overview
            if (!playerId) {
                camera.x = 0;
                camera.y = 0;
                camera.zoom = 0.5;

                drawGrid();
                drawMapBorder();

                if (gameState) {
                    gameState.polygons.filter(p => isInViewport(p, p.size)).forEach(drawPolygon);
                    gameState.players.filter(p => isInViewport(p, p.size)).forEach(drawTank);
                }

                ctx.restore();
                requestAnimationFrame(render);
                return;
            }

            const player = gameState.players.find(p => p.id === playerId);
            if (!player) {
                ctx.restore();
                requestAnimationFrame(render);
                return;
            }

            // Smooth camera follow with acceleration
            targetCamera.x = player.x;
            targetCamera.y = player.y;

            const cameraSpeed = 0.15;
            camera.x += (targetCamera.x - camera.x) * cameraSpeed;
            camera.y += (targetCamera.y - camera.y) * cameraSpeed;

            // Draw everything (with frustum culling)
            drawGrid();
            drawMapBorder();

            // Draw polygons (only visible ones)
            gameState.polygons.filter(p => isInViewport(p, p.size)).forEach(drawPolygon);

            // Draw traps (only visible ones)
            gameState.traps.filter(t => isInViewport(t, t.size)).forEach(drawTrap);

            // Draw bullets (only visible ones)
            gameState.bullets.filter(b => isInViewport(b, b.size)).forEach(drawBullet);

            // Draw minions (only visible ones)
            gameState.minions.filter(m => isInViewport(m, m.size)).forEach(drawMinion);

            // Draw tanks (only visible ones)
            gameState.players.filter(p => isInViewport(p, p.size)).forEach(drawTank);

            // Draw minimap
            drawMinimap();

            ctx.restore();
            requestAnimationFrame(render);
        }

        // Add buttons to main menu when admin panel is active
        if (cheatPanelActive) {
            const mainMenu = document.getElementById('startMenu');

            // Clear All Blocks Button
            const clearBlocksBtn = document.createElement('button');
            clearBlocksBtn.textContent = 'Clear All Blocks';
            clearBlocksBtn.style = 'margin: 10px; padding: 10px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;';
            clearBlocksBtn.addEventListener('click', () => {
                socket.emit('clearAllBlocks');
                alert('All blocks cleared!');
            });
            mainMenu.appendChild(clearBlocksBtn);

            // Toggle Invincibility Button
            const toggleInvincibilityBtn = document.createElement('button');
            toggleInvincibilityBtn.textContent = 'Toggle Invincibility on Start';
            toggleInvincibilityBtn.style = 'margin: 10px; padding: 10px; background: #44ff44; color: white; border: none; border-radius: 5px; cursor: pointer;';
            toggleInvincibilityBtn.addEventListener('click', () => {
                socket.emit('toggleInvincibility');
                alert('Invincibility toggled!');
            });
            mainMenu.appendChild(toggleInvincibilityBtn);
        }

        // Automatically grant admin privileges on spawn
        socket.on('playerSpawned', () => {
            if (cheatPanelActive) {
                socket.emit('grantAdmin');
                console.log('Admin privileges granted on spawn.');
            }
        });
    </script>
</body>
</html>

